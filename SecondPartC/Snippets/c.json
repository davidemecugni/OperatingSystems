{
	"prima riga": {
		"prefix": "prima",
		"body": [
			"//Using C11",
			"//YOUR NAME",
			"//File ${TM_FILENAME}",
			"$1"
		]
	},
	"main": {
		"prefix": "main",
		"body": [
			"int main(int argc, char* argv[]) {",
			"    $1",
			"    exit(0);",
			"}"
		]
	},
	"librerie": {
		"prefix": "lib",
		"body": [
			"#include <stdio.h> //Standard I/O: printf, BUFSIZ",
			"#include <fcntl.h> //File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR, O_CREAT(crea se non esiste), O_APPEND(solo R o RW)",
			"//O_TRUNC(distrugge contenuto se esiste, O_EXCL(fallisce se il file esiste gia'), O_NDELAY (non bloccante per FIFO e pipe in W)",
			"#include <stdlib.h> //STanDard LIBrary: exit, malloc, calloc, atoi",
			"#include <unistd.h> //UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END",
			"#include <string.h> //STRING: strlen, strcpy, strcat",
			"#include <sys/stat.h> //SYStem STATus: stat, fstat, S_IFMT, S_IFDIR, S_IFREG",
			"#include <sys/wait.h> //SYStem WAIT: wait",
			"#include <errno.h> //ERror NUmber: errno",
			"#include <sys/types.h> //SYStem TYPES: pid_t",
			"#include <ctype.h> //ISoType: isdigit, isalpha, isalnum",
			"$1"
		]
	},
	"copia file": {
		"prefix": "copiafile",
		"body": [
			"//CONTROLLA I CODICI DI ERRORE",
			"int copyfile (char *f1, char * f2) {",
			"    int infile, outfile, nread;",
			"    char buffer [BUFSIZ]; // Usato per i caratteri",
			"    if (( infile = open (f1, O_RDONLY)) < 0 ){",
			"        //Errore nell'apertura in lettura del primo file",
			"        return 1;",
			"    }",
			"    if (( outfile = creat (f2, ${1:permission})) <0 ) {",
			"        //Errore nella creazione del secondo file",
			"        close (infile);", 
			"        return 2;",
			"    }",
			"    while (( nread = read (infile, buffer, BUFSIZ)) > 0 ) {",
			"        if ( write (outfile , buffer, nread ) < nread ) {",
			"            //Errore nella scrittura del file",
			"            close (infile);", 
			"            close (outfile);",
			"        return 3;",
			"        }",
			"    }",
			"    close (infile);",
			"    close (outfile);",
			"    //File copiato correttamente",
			"    return 0;",
			"}"
		],
		"description": "Copies a file"
	},
	"pappagallo": {
        "prefix": "pappagallo",
        "body": [
            "char buffer [BUFSIZ];",
            "int nread;",
            "while ( (nread = read (0, buffer, BUFSIZ)) > 0 ) {",
            "    /* lettura dallo standard input fino a che ci sono caratteri */",
            "    write (1 , buffer, nread);",
            "    /* scrittura sullo standard output dei caratteri letti */",
            "}"
        ],
        "description": "Reads from standard input and writes to standard output"
    },
	"Appendi file": {
		"prefix": "appendifilestdin",
		"body": [
			"//CONTROLLA I CODICI DI ERRORE",
			"int appendfile (char *f1)",
			"{ int outfile, nread; char buffer [BUFSIZ];",
			"    if ( (outfile = open ( f1, O_WRONLY)) < 0 )",
			"    /* apertura in scrittura */",
			"    { ",
			"        if (( outfile = creat ( f1, PERM)) <0 )",
			"        /* se il file non esiste, viene creato */",
			"            return (-1); }",
			"        else ",
			"        /* se il file esiste, ci si posiziona alla fine */",
			"            lseek (outfile, 0L, 2);",
			"        ",
			"    while (( nread = read (0, buffer, BUFSIZ)) > 0 ) /* si legge dallo standard input */",
			"    {   ",
			"        if ( write (outfile, buffer, nread ) < nread )",
			"        { ",
			"            close (outfile); ",
			"            return (-2); /* errore */ }",
			"    }",
			"    /* fine del file di input */",
			"    close (outfile); ",
			"    return (0);",
			"}"
		],
		"description": "Appendi file"
	},
	"Muovi file": {
	"prefix": "movefile",
	"body": [
		"//CONTROLLA CODICE DI RITORNO",
		"int mv(char *file1, char *file2)",
		"{ ",
		"    /* controllo del numero di parametri */",
		"    if (link(file1, file2) < 0)",
		"    { ",
		"        printf (\"Errore\\n\"); ",
		"        return 1;",
		"    }",
		"    /* controllo sulla operazione di link */",
		"    if (unlink(file1) < 0)",
		"    { ",
		"        printf (\"Errore\\n\"); ",
		"        return 2;",
		"    }",
		"    /* controllo sulla operazione di unlink */",
		"    printf (\"DEBUG: Ok\\n\"); ",
		"    return 0;",
		"}"
	],
	"description": "Muovi file"
	},
	"file OK": {
	"prefix": "fileOK",
	"body": [
		"void fileOK(char* fileName)",
		"{",
		"    if (access(fileName, F_OK) == 0)",
		"        printf(\"DEBUG: OK file\\n\");",
		"    else ",
		"        printf(\"DEBUG: NO file\\n\");",
		"}"
	],
	"description": "file OK"
	},
	"diritti file": {
	"prefix": "fileDiritti",
	"body": [
		"void dirittiFile(char* fileName)",
		"{",
		"    if (access(fileName, F_OK) == 0)",
		"        printf(\"DEBUG:  OK file\\n\");",
		"    else ",
		"        printf(\"DEBUG: NO file\\n\");",
		"    if (access(fileName, R_OK) == 0)",
		"        printf(\"DEBUG: OK lettura\\n\");",
		"    else ",
		"        printf(\"DEBUG: NO lettura\\n\");",
		"    if (access(fileName, W_OK) == 0)",
		"        printf(\"DEBUG: OK scrittura\\n\");",
		"    else ",
		"        printf(\"DEBUG: NO scrittura\\n\");",
		"    if (access(fileName, X_OK) == 0)",
		"        printf(\"DEBUG: OK esecuzione\\n\");",
		"    else ",
		"        printf(\"DEBUG: NO esecuzione\\n\");",
		"}"
	],
	"description": "diritti file"
	},
	"stat print": {
	"prefix": "statPrint",
	"body": [
		"void statPrint(char *file)",
		"{ ",
		"    struct stat b;",
		"    if (stat(file, &b) != 0)",
		"    { ",
		"        printf(\"DEBUG: NO!!!\\n\"); ",
		"        exit(-2); ",
		"    }",
		"    printf(\"st-dev=%ld\\n\", b.st_dev);",
		"    printf(\"st-ino=%ld\\n\", b.st_ino);",
		"    printf(\"st-mode=%ld\\n\", b.st_mode);",
		"    printf(\"st-nlink=%ld\\n\", b.st_nlink);",
		"    printf(\"st-uid=%ld\\n\", b.st_uid);",
		"    printf(\"st-gid=%ld\\n\", b.st_gid);",
		"    printf(\"st-rdev=%ld\\n\", b.st_rdev);",
		"    printf(\"st-size=%ld\\n\", b.st_size);",
		"    printf(\"st-atime=%ld\\n\", b.st_atime);",
		"    printf(\"st-mtime=%ld\\n\", b.st_mtime);",
		"    printf(\"st-ctime=%ld\\n\", b.st_ctime);",
		"}"
	],
	"description": "stat print"
	},
	"fstat print": {
	"prefix": "fstatPrint",
	"body": [
		"void fstatPrint(char *file)",
		"{ ",
		"    int fd; ",
		"    struct stat b;",
		"    //Per usare fstat bisogna aprire il file",
		"    if ((fd=open(file, 0)) <= 0)",
		"    { ",
		"    printf(\"NO OPEN!!!\\n\"); ",
		"    exit(-2);",
		"    }",
		"    //Se fstat non restituisce 0 c'e' stato un errore",
		"    if (fstat(fd, &b) != 0)",
		"    { ",
		"    printf(\"NO!!!\\n\"); ",
		"    exit(-3); ",
		"    }",
		"    printf(\"st-dev=%ld\\n\", b.st_dev);",
		"    printf(\"st-ino=%ld\\n\", b.st_ino);",
		"    printf(\"st-mode=%ld\\n\", b.st_mode);",
		"    printf(\"st-nlink=%ld\\n\", b.st_nlink);",
		"    printf(\"st-uid=%ld\\n\", b.st_uid);",
		"    printf(\"st-gid=%ld\\n\", b.st_gid);",
		"    printf(\"st-rdev=%ld\\n\", b.st_rdev);",
		"    printf(\"st-size=%ld\\n\", b.st_size);",
		"    printf(\"st-atime=%ld\\n\", b.st_atime);",
		"    printf(\"st-mtime=%ld\\n\", b.st_mtime);",
		"    printf(\"st-ctime=%ld\\n\", b.st_ctime);",
		"}"
	],
	"description": "fstat print"
	},
	"controllo file": {
	"prefix": "controlloFile",
	"body": [
		"//Controllo se e' un file",
		"if( open(${1:stringa}, O_RDONLY) < 0){",
		"    printf(\"Errore: il parametro %s non e' un file\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo file"
	},
	"controllo numero": {
	"prefix": "controlloNumero",
	"body": [
		"//Controllo se e' un numero",
		"int n = atoi(${1:stringa});",
		"if(n <= 0){",
		"    printf(\"Errore: il parametro %s non e' un numero positivo\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo numero"
	},
	"Controllo numero con sscanf": {
	"prefix": "controlloNumeroSscanf",
	"body": [
		"int n;",
		"//Controllo che e' un numero con sscanf",
		"if (sscanf(${1:PARAMETRO}, \"%d\", &n) != 1) {",
		"    printf(\"Errore, il parametro %s passato non e' un numero\", ${1:PARAMETRO});",
		"    exit(${2:EXICODE});",
		"} ",
		"  "
	],
	"description": "Controllo numero con sscanf"
	},
	"controllo carattere": {
	"prefix": "controlloCarattere",
	"body": [
		"//Controllo se e' un carattere",
		"//ARRAY DI CARATTERI",
		"if(${1:stringa}[1] != '\\0'){",
		"    printf(\"Errore: il parametro %s non e' un carattere\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo carattere"
	},
	"controllo numero di parametri": {
	"prefix": "controlloParametri",
	"body": [
		"//Controllo esatto parametri",
		"if(argc != ${1:parametri+1}){",
		"    printf(\"Errore: inserire esattamente  ${2:PARAMETRI} parametri, argc = %d\\n\", argc);",
		"    exit(${3:EXITCODE});",
		"}"
	],
	"description": "controllo numero di parametri"
	},
	"conta numero di caratteri uguali a Cx in file": {
	"prefix": "contaCharUgualiACx",
	"body": [
		"//Ritorna il numero di occorrenze del carattere Cx nel file F",
		"long int contaOccorrenzeCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    long int occorrenze = 0;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            occorrenze++;",
		"        }",
		"    }",
		"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
		"    close(fd);",
		"    return occorrenze;",
		"}"
	],
	"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"conta occorrenze di caratteri uguali  a Cx in file": {
	"prefix": "contaOccorrenzeCharUgualiACx",
	"body": [
		"//Ritorna il numero di occorrenze del carattere Cx nel file F",
		"long int contaOccorrenzeCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    long int occorrenze = 0;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            occorrenze++;",
		"        }",
		"    }",
		"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
		"    close(fd);",
		"    return occorrenze;",
		"}"
	],
	"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"Cat": {
	"prefix": "cat",
	"body": [
		"//Se file non esiste, usa lo standard input",
		"void myCat(char* file)",
		"{       ",
		"    int nread;                      // valore ritorno read ",
		"    char buffer[BUFSIZ];            // usato per i caratteri ",
		"    int fd = 0;                     // usato per la open; N.B. se non viene passato alcun parametro allora rimarra' uguale a 0, quindi identifichera' lo STANDARD INPUT ",
		"",
		"    if ((fd = open(file, O_RDONLY)) < 0)// ERRORE se non si riesce ad aprire in LETTURA il file ",
		"    {       printf(\"Errore in apertura file %s dato che fd = %d\\n\", file, fd);",
		"            exit(${1:EXITCODE}); ",
		"    }",
		"",
		"    while ((nread = read(fd, buffer, BUFSIZ)) > 0 ){",
		"        // scrittura sullo standard output dei caratteri letti ",
		"        write(1, buffer, nread);",
		"    }",
		"    if(fd != 0){",
		"        close(fd);",
		"    }",
		"}"
	],
	"description": "Cat"
	},
	"Lunghezza file con open": {
	"prefix": "fileLunghezzaConOpen",
	"body": [
		"long lunghezzaFileConOpen(const char* file){",
		"    int fd = open(file, O_RDONLY);",
		"    long lenght = lseek(fd, 0, SEEK_END);",
		"    close(fd);",
		"    return lenght;",
		"}"
	],
	"description": "Lunghezza file con open"
	},
	"Stampa l'n-esimo carattere in un file con read": {
	"prefix": "stampaNEsimoCarattereInFileConRead",
	"body": [
		"//Stampa l'n-esimo carattere nel file fornito",
		"void stampaNEsimoCarattereInFileConRead(const char *F, int n){",
		"    //Apertura file",
		"    int fd, num;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    char *buffer = malloc(sizeof(char) * n);",
		"    if(buffer == NULL){",
		"        printf(\"Impossibile allocare dinamicamente la memoria\\n\");",
		"        exit(5);",
		"    }",
		"    //Lettura file carattere per carattere",
		"    while((num = read(fd, buffer, n)) > 0){",
		"        printf(\"Il carattere multiplo %d-esimo all'interno del file %s e' %c\\n\", n,F,buffer[num-1]);",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "Stampa l'n-esimo carattere in un file con read"
	},
	"Stampa l'n-esimo carattere in un file con lseek": {
	"prefix": "stampaNEsimoCarattereInFileConlseek",
	"body": [
		"void stampaNEsimoCarattereInFileConlseek(const char* F, int n){",
		"    int fd;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    long lunghezzaF = lseek(fd, 0, SEEK_END);",
		"    char c;",
		"    for(long i=n-1;i-1<lunghezzaF;i+=n){",
		"        lseek(fd, (int)i, SEEK_SET);",
		"        if(read(fd, &c, 1) == -1){",
		"            printf(\"Errore durante la lettura del file\\n\");",
		"            exit(5);",
		"        }",
		"        printf(\"Il carattere multiplo %d-esimo all'interno del file %s e' %c\\n\", n,F,c);",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "Stampa l'n-esimo carattere in un file con lseek"
	},
	"file char per char": {
	"prefix": "fileCharPerChar",
	"body": [
		"// File char per char",
		"void fileCharPerChar(const char *F){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "file char per char"
	},
	"file sostituisci carattere con lo spazio": {
	"prefix": "fileSostituisciCarattere",
	"body": [
		"// Apertura file RW e sostituzione del carattere Cx con lo spazio",
		"void fileSostituisciCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDWR)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    char buffer;",
		"    const char spazio = ' ';",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            lseek(fd, -1, SEEK_CUR);",
		"            write(fd, &spazio, 1);",
		"        }",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "file sostituisci carattere con lo spazio"
	},
	"file In stampato a file Out": {
	"prefix": "fileMyHead",
	"body": [
		"// f char per char finche' non si trovano n /n",
		"void myhead(const char* f, int num){",
		"    char buffer;",
		"    int contaACapo = 0, n, fd;",
		"    //Se il file e' null leggo da STDIN",
		"    if(f == NULL){",
		"        fd = STDIN_FILENO;",
		"    }",
		"    else{",
		"        if((fd = open(f, O_RDONLY)) < 0){",
		"            printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"            exit(${1:EXITCODE});",
		"        }",
		"    }",
		"    //Leggo e mi fermo quando gli a capo sono == num",
		"    while(((n = read(fd, &buffer, 1)) > 0) && contaACapo < num){",
		"        if(buffer == '\\n'){",
		"            contaACapo++;",
		"        }",
		"        write(STDOUT_FILENO, &buffer, 1);",
		"    }",
		"}"
	],
	"description": "file In stampato a file Out"
	},
	"n esima riga di un file": {
	"prefix": "fileNesimaRiga",
	"body": [
		"// f char per char finche' non si trova l'n-esima riga",
		"//ATTENZIONE: il buffer deve essere abbastanza grosso",
		"int nEsimaRiga(const char* f, int num, char *buffer){",
		"    int contaACapo = 0, fd;",
		"   ",
		"    if((fd = open(f, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    }",
		"    int j=0;",
		"",
		"    while ((read(fd, &(buffer[j]), 1) != 0) && contaACapo < num){",
		"        if(buffer[j] == '\\n'){",
		"            contaACapo++;",
		"            buffer[j] = '\\0';",
		"            j = 0;",
		"            continue;",
		"        }",
		"        ++j;",
		"    }",
		"    ",
		"    return contaACapo == num;",
		"}"
	],
	"description": "n esima riga di un file"
	},
	"righe lunghe n caratteri": {
	"prefix": "fileRigheLungheN",
	"body": [
		"// f char per char finche' non si trova l'n-esima riga",
		"//ATTENZIONE: il buffer deve essere abbastanza grosso",
		"void righeLungheN(const char* f, int num){",
		"    char buffer[256];",
		"    int fd;",
		"    if((fd = open(f, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"        exit(${1:EXITCODE});",
		"    }",
		"",
		"    int j=0;",
		"    int righeTrovate = 1;",
		"    while ((read(fd, &(buffer[j]), 1) != 0) && j<255){",
		"        if(buffer[j] == '\\n'){",
		"            buffer[j] = '\\n';",
		"            buffer[j+1] = '\\0';",
		"            if(j + 1 == num){",
		"                printf(\"Trovata %d-esima riga: %s\", righeTrovate, buffer);",
		"                righeTrovate++;",
		"            }",
		"            j = 0;",
		"            continue;",
		"        }",
		"        ++j;",
		"    }",
		"}"
	],
	"description": "righe lunghe n caratteri"
	},
	"generazione numero random": {
		"prefix": "random",
		"body": [
		  "#include <time.h>",
		  "//DA AGGIUNGERE NEL MAIN",
		  "//srand(time(NULL));",
		  "//PER OTTENERE RANDOM",
		  "//int r = rand();"
		],
		"description": "generazione numero random"
	},
	"gestione completa figlio": {
		"prefix": "figlio",
		"body": [
			"int pid, pidFiglio; /* pid per fork e pidFiglio per wait */",
			"int pidPadre = getpid();",
			"printf(\"DEBUG: La pid del padre e' :%d\\n\", pidPadre);",
			"if ((pid = fork()) < 0)",
			"{",
			"    //Fork fallita",
			"    printf(\"Errore in fork\\n\");",
			"    exit(${1:EXITCODE});",
			"}",
			"",
			"if (pid == 0)",
			"{ ",
			"    /* CODICE DEL FIGLIO*/",
			"",
			"",
			"    exit(CODICEDUSCITA);",
			"    /*FINE CODICE DEL FIGLIO*/",
			"}",
			"",
			"/* padre */",
			"printf(\"DEBUG: Generato figlio con PID = %d\\n\", pid);",
			"// Il padre aspetta il figlio salvando lo status",
			"int status;",
			"if ((pidFiglio=wait(&status)) < 0)",
			"{",
			"    //La wait non ha avuto successo",
			"    printf(\"Errore in wait\\n\");",
			"    exit(${2:EXITCODE});",
			"}",
			"//Se il pid ritornato dalla wait e' corretto",
			"if (pid == pidFiglio){",
			"    printf(\"DEBUG: Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        printf(\"DEBUG: Il figlio e' ritornato con codice: %d\\n\", WEXITSTATUS(status));",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}",
			"else ",
			"{       ",
			"    //Il pid non corrisponde con il figlio aspettato",
			"    printf(\"Il pid della wait non corrisponde al pid della fork!\\n\");",
			"    exit(${3:EXITCODE});",
			"}"
		],
		"description": "gestione completa figlio"
	},
	"leggi numero in input ": {
	"prefix": "inputNumero",
	"body": [
		"int ${1:NUMEROLETTO};",
		"printf(\"Inserire numero\\n\");",
		"if( scanf(\"%d\",&${1:NUMEROLETTO}) != 1){",
		"    printf(\"Numero non letto correttamente!\\n\");",
		"}"
	],
	"description": "leggi numero in input "
	},
	"creazione multipli figli N": {
		"prefix": "figliNSenzaPID",
		"body": [
			"pid_t pid;",
			"pid_t pidPadre = getpid();",
			"int N = ${1:FIGLI}",
			"printf(\"DEBUG: La pid del padre e' :%d\\n\", pidPadre);",
			"printf(\"DEBUG: Il padre deve generare %d figli\\n\", N);",
			"",
			"// Per la creazione di N figli",
			"for(int i=0; i < N; i++){",
			"    if ((pid = fork()) < 0)",
			"    {",
			"        //Fork fallita",
			"        printf(\"Errore in fork\\n\");",
			"        exit(${2:ERRORE});",
			"    }",
			"    ",
			"    if (pid == 0)",
			"    { ",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"DEBUG: Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(i);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"DEBUG: Generato figlio con PID = %d\\n\", pid);",
			"}",
			"",
			"/* padre */",
			"pid_t pidFiglio;",
			"int status, ritorno;",
			"// Il padre aspetta i figli salvando lo status",
			"for(int i=0; i<N;i++){",
			"    if ((pidFiglio=wait(&status)) < 0)",
			"    {",
			"        //La wait non ha avuto successo",
			"        printf(\"Errore in wait\\n\");",
			"        exit(${3:ERRORE});",
			"    }",
			"",
			"    printf(\"DEBUG: Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"DEBUG: Il figlio e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}"
		],
		"description": "creazione multipli figli N"
	},
	"creazione multipli figli N con salvataggio PID": {
		"prefix": "figliNConSalvataggioPID",
		"body": [
			"int N = ${1:NUMEROFIGLI};",
			"printf(\"DEBUG: La pid del padre e' :%d\\n\", pidPadre);",
			"printf(\"DEBUG: Il padre deve generare %d figli\\n\", N);",
			"",
			"pid_t *pidDeiFigli = malloc(N*sizeof(pid_t));",
			"",
			"if(pidDeiFigli == NULL){",
			"    printf(\"Errore nell'allocazione della memoria\\n\");",
			"    exit(${2:ERRORE});",
			"}",
			"",
			"// Per la creazione di N figli",
			"for(int i=0; i < N; i++){",
			"    if ((pidDeiFigli[i] = fork()) < 0)",
			"    {",
			"        //Fork fallita",
			"        printf(\"Errore in fork\\n\");",
			"        exit(${3:ERRORE});",
			"    }",
			"    ",
			"    if (pidDeiFigli[i] == 0)",
			"    { ",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"DEBUG: Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(EXITCODEFIGLIO);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"DEBUG: Generato figlio con PID = %d\\n\", pid);",
			"}",
			"",
			"/* padre */",
			"pid_t pidFiglio;",
			"int status, ritorno;",
			"// Il padre aspetta i figli salvando lo status",
			"for(int i=0; i<N;i++){",
			"    if ((pidFiglio=wait(&status)) < 0)",
			"    {",
			"        //La wait non ha avuto successo",
			"        printf(\"Errore in wait\\n\");",
			"        exit(${4:ERRORE});",
			"    }",
			"",
			"    int posizione = 0;",
			"    for(int j=0; j<N; j++){",
			"        if(pidDeiFigli[j] == pidFiglio){",
			"            posizione = j;",
			"            break;",
			"        }",
			"    }",
			"    //Posizione partendo da 0",
			"    printf(\"DEBUG: Terminato figlio con PID = %d, creato per %d-esimo\\n\", pidFiglio, posizione);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"DEBUG: Il figlio e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}",
			"//Libero la memoria dove ho salvato i PID dei figli",
			"free(pidDeiFigli);"
		],
		"description": "creazione multipli figli N con salvataggio PID"
	},
	"creaFileEsisteNonEsiste": {
		"prefix": "creaFileEsisteNonEsiste",
		"body": [
		  "//Controllo se un file esiste, se non esiste lo creo in scrittura",
		  "if((fd = open (\"${1:FILENAME}\", O_CREAT | O_EXCL | O_WRONLY, ${2:PERMESSI})) < 0 ){",
		  "    // Se il file esiste gia'",
		  "    printf(\"DEBUG: Il file ${1:FILENAME} esiste gia'\\n\");",
		  "}",
		  "",
		  "printf(\"DEBUG: Il file ${1:FILENAME} non esisteva: creato\\n\");",
		  "// Scrivo nel file"
		],
		"description": "creaFileEsisteNonEsiste"
	},
	"creaFileTroncando": {
		"prefix": "creaFileTroncando",
		"body": [
		  "// Controllo se un file esiste, se esiste lo tronco",
		  "if ( (fd= open (\"${1:FILENAME}\", O_TRUNC | O_WRONLY)) < 0 )",
		  "{",
		  "    printf(\"DEBUG: Il file ${1:FILENAME} non esiste\\n\");",
		  "    exit(${2:ERRORCODE});",
		  "    ",
		  "}",
		  "//Se il file esiste gia' lo abbiamo troncato",
		  "// Scrivo nel file"
		],
		"description": "creaFileTroncando"
	},
	"creaFileSenzaControllo": {
		"prefix": "creaFileSenzaControllo",
		"body": [
		  "// Apro il file in scrittura, se non esiste lo creo, se esiste puo' dare errori",
		  "if ( (fd = open (\"${1:FILENAME}\", O_CREAT | O_WRONLY, ${2:PERMESSI})) < 0 )",
		  "{ ",
		  "    printf(\"Errore in creazione file ${1:FILENAME}\\n\");",
		  "    exit(${3:ERRORCODE});",
		  "}",
		  "//Se siamo qui il file e' stato creato correttamente",
		  "printf(\"DEBUG: Creato il file ${1:FILENAME}\\n\");"
		],
		"description": "creaFileSenzaControllo"
	},
	"print di debug": {
		"prefix": "debug",
		"body": [
		  "printf(\"DEBUG: ${1:MESSAGGIO}\");"
		],
		"description": "print di debug"
	},
	"print di errore": {
		"prefix": "errore",
		"body": [
		  "printf(\"ERRORE: ${1:MESSAGGIO}\");"
		],
		"description": "print di debug"
	},
	"figliNipoti": {
		"prefix": "figliNipoti",
		"body": [
			"// Numero di processi figli da creare",
			"N=${1:NRFIGLI}; ",
			"",
			"printf(\"DEBUG-Sono il processo padre con pid %d e creero' %d processi figli che generanno a loro volta ognuno un nipote\\n\", getpid(), N);",
			"",
			"/* creazione figli */",
			"for (i=0;i<N;i++){",
			"",
			"    if ((pid=fork())<0){",
			"        printf(\"Errore creazione figlio %d-esimo\\n\", i);",
			"        exit(${2:EXITCODE});",
			"    }",
			"    if (pid==0){",
			"        ",
			"        /* CODICE FIGLIO*/",
			"        /* in caso di errore (sia nei figli che nei nipoti) decidiamo di ritornare -1 che sara' interpretato dal padre come 255 e quindi un valore non valido */",
			"",
			"        printf(\"DEBUG-Sono il figlio %d di indice %d\\n\", getpid(), i);",
			"",
			"",
			"        /* ogni figlio crea un nipote */",
			"        if ( (pid = fork()) < 0) {",
			"            printf(\"Errore nella fork di creazione del nipote\\n\");",
			"            exit(-1); ",
			"        }",
			"        if (pid == 0)",
			"        {",
			"            /* CODICE NIPOTE */",
			"            printf(\"DEBUG-Sono il processo nipote del figlio di indice %d e pid %d sto per eseguire il comando sort per il file %s\\n\", i, getpid(), argv[i+1]); ",
			"            ",
			"            // Esecuzione di un comando con exec",
			"            execlp();",
			"",
			"            /* Se arriva qui c'e' un errore*/",
			"            printf(\"Errore nella execlp\\n\");",
			"            exit(-1); ",
			"",
			"            /* FINE CODICE NIPOTE */",
			"        }",
			"",
			"        /* CONTINUA FIGLIO */",
			"        /* il figlio deve aspettare il nipote per ritornare, a sua volta, al padre il valore tornato dal nipote  */",
			"        if ((pidFiglio=wait(&status)) < 0){",
			"            printf(\"Errore in wait\\n\");",
			"            exit(-1); ",
			"        }",
			"        if (!WIFEXITED(status)){",
			"            printf(\"DEBUG: Nipote con pid %d terminato in modo anomalo\\n\", pidFiglio);",
			"            // il figlio torna -1 che sara' interpretato dal padre come 255 e quindi un valore di errore",
			"            exit(-1); ",
			"        }",
			"        else{",
			"            ritorno=WEXITSTATUS(status);",
			"            printf(\"DEBUG: Il nipote con pid=%d ha ritornato %d(se 255 problemi!)\\n\", pidFiglio, ritorno);",
			"        }",
			"        ",
			"        /* il figlio ritorna il valore ricevuto dal nipote  */",
			"        exit(ritorno);",
			"        /* FINE CODICE FIGLIO */",
			"    }",
			"} ",
			"",
			"/* CONTINUA PADRE PADRE */",
			"/* Il padre aspetta i figli */",
			"for (i=0; i < N; i++)",
			"{",
			"    if ((pidFiglio=wait(&status)) < 0){",
			"        printf(\"Errore in wait\\n\");",
			"        exit(${3:EXITCODE});",
			"    }",
			"    if (!WIFEXITED(status)){",
			"        printf(\"DEBUG: Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
			"    }",
			"    else{ ",
			"        ritorno=WEXITSTATUS(status);",
			"        printf(\"DEBUG: Il figlio con pid=%d ha ritornato %d (se 255 problemi!)\\n\", pidFiglio, ritorno);",
			"    } ",
			"}"
		],
		"description": "figliNipoti"
		},
		"pipe di N canali con N non conosciuto a priori": {
			"prefix": "pipeNallocatiDinamicamente",
			"body": [
				"// 1) DEFINIZIONE ARRAY DINAMICO piped",
				"typedef int pipe_t[2]; /* definizione del TIPO pipe_t come array di 2 interi */",
				"",
				"pipe_t *piped; /* array dinamico di pipe descriptors per comunicazioni",
				"figli-padre */",
				"// 2) ALLOCAZIONE ARRAY DINAMICO piped DI DIMENSIONE N â€“ ATTENZIONE: DA CONTROLLARE SEMPRE!",
				"/* Allocazione dell'array di N pipe descriptors */",
				"piped = (pipe_t *) malloc(N*sizeof(pipe_t));",
				"if (piped == NULL)",
				"{",
				"    printf(\"Errore nella allocazione della memoria\\n\");",
				"    exit(${1:ERRORE}); ",
				"}",
				"// 3) CREAZIONE DELLE N PIPE PER COMUNICAZIONE FIGLI-PADRE",
				"/* Creazione delle N pipe figli-padre */",
				"for (j=0; j < N; j++)",
				"{ ",
				"    if(pipe(piped[j]) < 0)",
				"    {  ",
				"        printf(\"Errore nella creazione della pipe\\n\");",
				"        exit(${2:ERRORE});     ",
				"    }",
				"}"
			],
			"description": "pipe di N canali con N non conosciuto a priori"
		},
		"chiusura pipe nei figli": {
		"prefix": "pipeChiusuraNeiFigli",
		"body": [
			"/* Chiusura delle pipe non usate nella comunicazione con il padre */",
			"for (k=0; k < N; k++)",
			"{ ",
			"    close(piped[k][0]);",
			"    if (k != i){",
			"        close(piped[k][1]);",
			"    }",
			"}"
		],
		"description": "chiusura pipe nei figli"
		},
		"chiusura pipe nel padre": {
		"prefix": "pipeChiusuraNelPadre",
		"body": [
			"/* padre chiude tutte le pipe che non usa */",
			"for (k=0; k < N; k++)",
			"{",
			"    close(piped[k][1]);",
			"}"
		],
		"description": "chiusura pipe nel padre"
		},
	"Variabili": {
		"prefix": "variabiliLocali",
		"body": [
			"/* -------- Variabili locali ---------- */",
			"typedef int pipe_t[2]; /* definizione del TIPO pipe_t come array di 2 interi */",
			"int pid;                /* process identifier per le fork() */",
			"int N;                 /* numero di file passati sulla riga di comando (uguale al numero di file) */",
			"int status;            /* variabile di stato per la wait */",
			"pipe_t *piped;         /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
			"pipe_t p;              /* una sola pipe per ogni coppia figlio-nipote */ ",
			"int i, j;              /* indici per i cicli */",
			"char numero[11];       /* array di caratteri per memorizzare la stringa corrispondente al numero di righe: ci vogliono 10 char per rappresentare un intero di 16 bit e poi ci sara' il carattere di \"a capo\" */",
			"int valore;            /* variabile che viene comunicata da ogni figlio al padre e che contiene la conversione della stringa numero */",
			"int ritorno;           /* variabile che viene ritornata da ogni figlio al padre e che contiene il ritorno del nipote */",
			"long int somma = 0;    /* variabile usata dal padre per calcolare la somma di tutte le lunghezze comunicate dai figli */",
			"int pidFiglio; /* pid figlio per wait */",
			"/* ------------------------------------ */"
		],
		"description": "Variabili"
	},
	"Struct": {
		"prefix": "structEsempio",
		"body": [
		  "typedef struct{",
		  "    int c1;",
		  "    int c2;",
		  "    char c3[250];",
		  "} msg;"
		],
		"description": "Struct"
	},
	"pipeChiusuraNeiNipoti": {
	"prefix": "pipeNipoteRedirezioneStdOut",
	"body": [
		"close(piped[i][1]);",
		"/* ogni nipote deve simulare il piping dei comandi nei confronti del figlio e quindi deve chiudere lo standard output e quindi usare la dup sul lato di scrittura della propria pipe */",
		"close(1);",
		"dup(p[1]);",
		"/* ogni nipote adesso puo' chiudere entrambi i lati della pipe: il lato 0 NON viene usato e il lato 1 viene usato tramite lo standard ouput */",
		"close(p[0]);",
		"close(p[1]); "
	],
	"description": "pipeChiusuraNeiNipoti"
	},
	"Figli e Nipoti con Pipe tra PF e PN": {
		"prefix": "figliNipotiConPipePFePN",
		"body": [
		  "// Numero di processi figli da creare",
		  "N = ${1:NUMEROFIGLIENIPOTI}; ",
		  "",
		  "",
		  "",
		  "/* Allocazione dell'array di N pipe descriptors */",
		  "pipePadreFigli = (pipe_t *) malloc(N*sizeof(pipe_t));",
		  "if(pipePadreFigli == NULL){",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(${2:EXITVALUE});",
		  "}",
		  "pipePadreNipoti = (pipe_t *) malloc(N*sizeof(pipe_t));",
		  "if(pipePadreNipoti == NULL){",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(${3:EXITVALUE});",
		  "}",
		  "int *pidFigli = (int *) malloc(N*sizeof(int));",
		  "if(pidFigli == NULL){",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(${4:EXITVALUE});",
		  "}",
		  "int *pidNipoti = (int *) malloc(N*sizeof(int));",
		  "if(pidNipoti == NULL){",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(${5:EXITVALUE});",
		  "}",
		  "// 3) CREAZIONE DELLE N PIPE PER COMUNICAZIONE FIGLI-PADRE",
		  "/* Creazione delle N pipe figli-padre */",
		  "for (j=0; j < N; j++)",
		  "{ ",
		  "    if(pipe(pipePadreFigli[j]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit(${6:EXITVALUE});     ",
		  "    }",
		  "    if(pipe(pipePadreNipoti[j]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit(${7:EXITVALUE});     ",
		  "    }",
		  "}    ",
		  "/* creazione figli */",
		  "for (i=0;i<N;i++){",
		  "    F = argv[i+1];",
		  "    if ((pidFigli[i]=fork())<0){",
		  "        printf(\"Errore creazione figlio %d-esimo\\n\", i);",
		  "        exit(${8:EXITVALUE});",
		  "    }",
		  "    if (pidFigli[i]==0){",
		  "        ",
		  "        /* CODICE FIGLIO*/",
		  "        for(j=0; j<N; j++){",
		  "            close(pipePadreFigli[j][0]);",
		  "            if(i != j){",
		  "                close(pipePadreFigli[j][1]);",
		  "            }",
		  "        }",
		  "        /* in caso di errore (sia nei figli che nei nipoti) decidiamo di ritornare -1 che sara' interpretato dal padre come 255 e quindi un valore non valido */    ",
		  "        /* ogni figlio crea un nipote */",
		  "        if ( (pidNipoti[i] = fork()) < 0) {",
		  "            printf(\"Errore nella fork di creazione del nipote\\n\");",
		  "            exit(-1); ",
		  "        }",
		  "        if (pidNipoti[i] == 0)",
		  "        {",
		  "            /* CODICE NIPOTE */",
		  "            // File char per char",
		  "            for(j=0; j<N; j++){",
		  "                close(pipePadreNipoti[j][0]);",
		  "                if(i != j){",
		  "                    close(pipePadreNipoti[j][1]);",
		  "                }",
		  "            }",
		  "            ",
		  "            // write(pipePadreNipoti[i][1], &trasformazioni, sizeof(trasformazioni));",
		  "            exit(DARIEMPIRE); ",
		  "",
		  "            /* FINE CODICE NIPOTE */",
		  "        }",
		  "",
		  "        /* CONTINUA FIGLIO */",
		  "        for(j=0; j<N; j++){",
		  "            close(pipePadreNipoti[j][0]);",
		  "            close(pipePadreNipoti[j][1]);",
		  "        }",
		  "        ",
		  "        // write(pipePadreFigli[i][1], &trasformazioni, sizeof(trasformazioni));",
		  "",
		  "        /* il figlio deve aspettare il nipote per ritornare, a sua volta, al padre il valore tornato dal nipote  */",
		  "        if ((pidFiglio=wait(&status)) < 0){",
		  "            printf(\"Errore in wait\\n\");",
		  "            exit(-1); ",
		  "        }",
		  "        if (!WIFEXITED(status)){",
		  "            printf(\"DEBUG: Nipote con pid %d terminato in modo anomalo\\n\", pidFiglio);",
		  "            // il figlio torna -1 che sara' interpretato dal padre come 255 e quindi un valore di errore",
		  "            exit(-1); ",
		  "        }",
		  "        else{",
		  "            ritorno=WEXITSTATUS(status);",
		  "            printf(\"Il nipote con pid=%d ha ritornato %d (se 255 problemi!)\\n\", pidFiglio, ritorno);",
		  "        }",
		  "        exit(DARIEMPIRE);",
		  "        /* FINE CODICE FIGLIO */",
		  "    }",
		  "} ",
		  "",
		  "/* CONTINUA PADRE PADRE */",
		  "",
		  "/* chiudo tutte le pipe che non uso */",
		  "for (j=0; j < N; j++)",
		  "{",
		  "    close(pipePadreFigli[j][1]);",
		  "    close(pipePadreNipoti[j][1]);",
		  "}",
		  "",
		  "/* leggo dai figli e dai nipoti*/",
		  "for (i=0; i < N; i++)",
		  "{",
		  "    //DA MODIFICARE",
		  "    if(read(pipePadreFigli[i][0], &trasformazioni, sizeof(trasformazioni)) < 0){",
		  "        printf(\"Errore nella lettura dalla pipe\\n\");",
		  "        exit(${9:EXITVALUE});",
		  "    }",
		  "    printf(\"Il figlio di indice %d(pid %d) ha trasformato %ld caratteri nel file %s\\n\", i, pidFigli[i], trasformazioni, argv[i+1]);",
		  "    //DA MODIFICARE",
		  "    if(read(pipePadreNipoti[i][0], &trasformazioni, sizeof(trasformazioni)) < 0){",
		  "        printf(\"Errore nella lettura dalla pipe\\n\");",
		  "        exit(${10:EXITVALUE});",
		  "    }",
		  "    printf(\"Il nipote di indice %d(pid %d) ha trasformato %ld caratteri nel file %s\\n\", i, pidNipoti[i], trasformazioni, argv[i+1]);",
		  "}",
		  "",
		  "",
		  "/* Il padre aspetta i figli */",
		  "for (i=0; i < N; i++)",
		  "{",
		  "    if ((pidFiglio=wait(&status)) < 0){",
		  "        printf(\"Errore in wait\\n\");",
		  "        exit(${11:EXITVALUE});",
		  "    }",
		  "    if (!WIFEXITED(status)){",
		  "        printf(\"DEBUG: Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
		  "    }",
		  "    else{ ",
		  "        ritorno=WEXITSTATUS(status);",
		  "        printf(\"Il figlio con pid=%d ha ritornato %d (se 255 problemi!)\\n\", pidFiglio, ritorno);",
		  "    } ",
		  "}",
		  ""
		],
		"description": "Figli e Nipoti con Pipe tra PF e PN"
	  },
	  "Figli con comunicazione tra figli, ultimo figlio con il padre": {
		"prefix": "figliConPipeFFeUltimoFP",
		"body": [
		  "pipe_t piped[26];         /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
		  "",
		  "",
		  "/* Creazione delle N pipe figli-padre */",
		  "for (j=0; j < N; j++)",
		  "{ ",
		  "    if(pipe(piped[j]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit(${1:EXITCODE});     ",
		  "    }",
		  "}",
		  "printf(\"DEBUG: La pid del padre e' :%d\\n\", getpid());",
		  "printf(\"DEBUG: Il padre deve generare %d figli\\n\", N);",
		  "",
		  "pid_t pidDeiFigli[NUMEROFIGLI];",
		  "",
		  "",
		  "// Per la creazione di N figli",
		  "for(int i=0; i < N; i++){",
		  "    if ((pidDeiFigli[i] = fork()) < 0)",
		  "    {",
		  "        //Fork fallita",
		  "        printf(\"Errore in fork\\n\");",
		  "        exit(${2:EXITCODE});",
		  "    }",
		  "    ",
		  "    if (pidDeiFigli[i] == 0)",
		  "    { ",
		  "        /* CODICE DEL FIGLIO*/",
		  "",
		  "        /* Chiusura delle pipe non usate nella comunicazione con il padre */",
		  "        for (j=0; j < N; j++)",
		  "        { ",
		  "            if (j != i){",
		  "                close(piped[j][1]);",
		  "            }",
		  "            if ((i == 0) || (j != i-1)){",
		  "                close (piped[j][0]);",
		  "            }",
		  "        }",
		  "    ",
		  "        printf(\"DEBUG: Figlio, pid: %d, indice %d\\n\", getpid(), i);",
		  "        ",
		  "",
		  "        dim = write(piped[i][1], &A, sizeof(A));",
		  "        if(dim != sizeof(A)){",
		  "            printf(\"Errore: impossibile scrivere sulla pipe\\n\");",
		  "            exit(-1);",
		  "        }",
		  "        ",
		  "        exit(buffer);",
		  "",
		  "        /*FINE CODICE DEL FIGLIO*/",
		  "    }",
		  "    printf(\"DEBUG: Generato figlio con PID = %d\\n\", pidDeiFigli[i]);",
		  "}",
		  "",
		  "",
		  "/* padre chiude tutte le pipe che non usa */",
		  "for (j=0; j < N-1; j++)",
		  "{",
		  "    close(piped[j][0]);",
		  "    close(piped[j][1]);",
		  "}",
		  "close(piped[N-1][1]);",
		  "",
		  "//Il padre legge il messaggio dall'ultimo figlio",
		  "dim = read(piped[N-1][0], &A, sizeof(A));",
		  "if(dim != sizeof(A)){",
		  "    printf(\"Errore: impossibile leggere dalla pipe\\n\");",
		  "    exit(${3:EXITCODE});",
		  "}",
		  "",
		  "",
		  "// RESTO PADRE",
		  "",
		  "// Il padre aspetta i figli salvando lo status",
		  "for(i=0; i<N;i++){",
		  "    if ((pidFiglio=wait(&status)) < 0)",
		  "    {",
		  "        //La wait non ha avuto successo",
		  "        printf(\"Errore in wait\\n\");",
		  "        exit(${4:EXITCODE});",
		  "    }",
		  "",
		  "    ",
		  "    if (WIFEXITED(status)) {",
		  "        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
		  "        ritorno = WEXITSTATUS(status);",
		  "        printf(\"Il figlio %d e' ritornato con %d, se 255 problemi!\\n\", pidFiglio, ritorno);",
		  "    } else {",
		  "        //Lo status riporta una terminazione anomala",
		  "        printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
		  "    }",
		  "}",
		  "",
		  ""
		],
		"description": "Figli con comunicazione tra figli, ultimo figlio con il padre"
	  },
	  "Figli e Nipoti con comunicazione Padri figli e figli nipoti tramite stdout rediretto a pipe": {
		"prefix": "figliNipotiConPipePFeFNtramiteRedStdOut",
		"body": [
		  "N=NRFIGLI;",
		  "printf(\"DEBUG-Sono il processo padre con pid %d e creero' %d processi figli che generanno a loro volta ognuno un nipote\\n\", getpid(), N);",
		  "piped = (pipe_t *) malloc(N*sizeof(pipe_t));",
		  "if (piped == NULL)",
		  "{",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(${1:EXITVALUE}); ",
		  "}",
		  "",
		  "// 3) CREAZIONE DELLE N PIPE PER COMUNICAZIONE FIGLI-PADRE",
		  "/* Creazione delle N pipe figli-padre */",
		  "for (j=0; j < N; j++)",
		  "{ ",
		  "    if(pipe(piped[j]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit(${2:EXITVALUE});     ",
		  "    }",
		  "}",
		  "/* creazione figli */",
		  "for (i=0;i<N;i++){",
		  "",
		  "    if ((pid=fork())<0){",
		  "        printf(\"Errore creazione figlio %d-esimo\\n\", i);",
		  "        exit(${3:EXITVALUE});",
		  "    }",
		  "    if (pid==0){",
		  "        ",
		  "        /* CODICE FIGLIO*/",
		  "        /* in caso di errore (sia nei figli che nei nipoti) decidiamo di ritornare -1 che sara' interpretato dal padre come 255 e quindi un valore non valido */",
		  "",
		  "        printf(\"DEBUG-Sono il figlio %d di indice %d\\n\", getpid(), i);",
		  "",
		  "        /* Chiusura delle pipe non usate nella comunicazione con il padre */",
		  "        for (int k=0; k < N; k++)",
		  "        { ",
		  "            close(piped[k][0]);",
		  "            if (k != i){",
		  "                close(piped[k][1]);",
		  "            }",
		  "        }",
		  "",
		  "        /* prima creiamo la pipe di comunicazione fra nipote e figlio */",
		  "        if(pipe(p) < 0)",
		  "        {",
		  "            printf(\"Errore nella creazione della pipe\\n\");",
		  "            exit(-1); /* decidiamo di tornare -1 che verra' interpretato dal padre come 255 e quindi un valore non ammissibile! */",
		  "        }",
		  "        //Creazione nipote",
		  "        if ( (pid = fork()) < 0)",
		  "        {",
		  "            printf(\"Errore nella fork di creazione del nipote\\n\");",
		  "            exit(-1);",
		  "        }",
		  "        if (pid == 0)",
		  "        {",
		  "            /* CODICE NIPOTE */",
		  "            /* codice del nipote */",
		  "            printf(\"DEBUG-Sono il processo nipote del figlio di indice %d e pid %d sto per calcolare il numero di linee del file %s\\n\", i, getpid(), argv[i+1]);",
		  "            /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
		  "            close(piped[i][1]);",
		  "            /* Ridirezione dello standard input:  il file si trova usando l'indice i incrementato di 1 (cioe' per il primo processo i=0 il file e' argv[1])i; NOTA BENE: IN QUESTO CASO LA RIDIREZIONE E' OBBLIGATORIA PER AVERE SULLO STANDARD OUTPUT SOLO LA STRINGA CORRISPONDENTE AL NUMERO! */",
		  "            close(0);",
		  "            if (open(argv[i+1], O_RDONLY) < 0)",
		  "            {",
		  "                printf(\"Errore nella open del file %s\\n\", argv[i+1]);",
		  "                exit(-1); /* decidiamo di tornare -1 che verra' interpretato dal padre come 255 e quindi un valore non ammissibile! */",
		  "            }",
		  "            close(1);",
		  "            dup(p[1]);",
		  "            /* ogni nipote adesso puo' chiudere entrambi i lati della pipe: il lato 0 non viene usato e il lato 1 viene usato tramite lo standard ouput */",
		  "            close(p[0]);",
		  "            close(p[1]);",
		  "            /* Ridirezione dello standard error su /dev/null (per evitare messaggi di errore a video): facoltativo! */",
		  "            close(2);",
		  "            open(\"/dev/null\", O_WRONLY);",
		  "            ",
		  "            /* Il nipote diventa il comando  */",
		  "            execlp(, (char *)0);",
		  "            ",
		  "            ",
		  "            /* Se arriva qui c'e' un errore*/",
		  "            exit(-1); ",
		  "",
		  "            /* FINE CODICE NIPOTE */",
		  "        }",
		  "",
		  "        /* CONTINUA FIGLIO */",
		  "",
		  "        close(p[1]);",
		  "        /* adesso il figlio legge dalla pipe un carattere alla volta */",
		  "        j=0;",
		  "        while (read(p[0], &(numero[j]), 1))",
		  "        {",
		  "            printf(\"indice j= %d carattere letto da pipe %c per figlio %d\\n\", j, numero[j], i);",
		  "            j++;",
		  "        }",
		  "",
		  "        if (j!=0) /* se il figlio ha letto qualcosa */",
		  "        {",
		  "            ",
		  "        }",
		  "",
		  "        /* il figlio comunica al padre */",
		  "        write(piped[i][1], &valore, sizeof(valore));",
		  "",
		  "        /* il figlio deve aspettare il nipote per ritornare, a sua volta, al padre il valore tornato dal nipote  */",
		  "        if ((pidFiglio=wait(&status)) < 0){",
		  "            printf(\"Errore in wait\\n\");",
		  "            exit(-1); ",
		  "        }",
		  "        ritorno = -1;",
		  "        if (!WIFEXITED(status)){",
		  "            printf(\"DEBUG: Nipote con pid %d terminato in modo anomalo\\n\", pidFiglio);",
		  "            // il figlio torna -1 che sara' interpretato dal padre come 255 e quindi un valore di errore",
		  "            exit(-1); ",
		  "        }",
		  "        else{",
		  "            ritorno=WEXITSTATUS(status);",
		  "            printf(\"DEBUG: Il nipote con pid=%d ha ritornato %d\\n\", pidFiglio, ritorno);",
		  "        }",
		  "        ",
		  "        ",
		  "        exit();",
		  "        /* FINE CODICE FIGLIO */",
		  "    }",
		  "} ",
		  "",
		  "/* CONTINUA PADRE PADRE */",
		  "/* padre chiude tutte le pipe che non usa */",
		  "for (int k=0; k < N; k++)",
		  "{",
		  "    close(piped[k][1]);",
		  "}",
		  "",
		  "/* Il padre legge i valori comunicati dai figli */",
		  "for (i=0; i < N; i++)",
		  "{",
		  "    read(piped[i][0], &valore, sizeof(valore));",
		  "    printf(\"Il figlio di indice %d ha comunicato il valore %d\\n\", i, valore);",
		  "}",
		  "",
		  "",
		  "/* Il padre aspetta i figli */",
		  "for (i=0; i < N; i++)",
		  "{",
		  "    if ((pidFiglio=wait(&status)) < 0){",
		  "        printf(\"Errore in wait\\n\");",
		  "        exit(${4:EXITVALUE});",
		  "    }",
		  "    if (!WIFEXITED(status)){",
		  "        printf(\"DEBUG: Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
		  "    }",
		  "    else{ ",
		  "        ritorno=WEXITSTATUS(status);",
		  "        printf(\"DEBUG: Il figlio con pid=%d ha ritornato %d (se 255 problemi!)\\n\", pidFiglio, ritorno);",
		  "    } ",
		  "}"
		],
		"description": "Figli e Nipoti con comunicazione Padri figli e figli nipoti tramite stdout rediretto a pipe"
	  },
	  "N figli sincronizzati a ring": {
		"prefix": "figliSincronizzatiARing",
		"body": [
		  "",
		  "N = ",
		  "",
		  "piped = (pipe_t *) malloc((N+1) *sizeof(pipe_t));",
		  "if (piped == NULL)",
		  "{",
		  "    printf(\"Errore nella allocazione della memoria\\n\");",
		  "    exit(); ",
		  "}",
		  "// 3) CREAZIONE DELLE N PIPE PER COMUNICAZIONE FIGLI-PADRE",
		  "/* Creazione delle N pipe figli-padre */",
		  "for (i=0; i < N+1; i++)",
		  "{ ",
		  "    if(pipe(piped[i]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit();     ",
		  "    }",
		  "}",
		  "// Per la creazione di N figli",
		  "for(int i=0; i < N; i++){",
		  "    if ((pid = fork()) < 0)",
		  "    {",
		  "        //Fork fallita",
		  "        printf(\"Errore in fork\\n\");",
		  "        exit();",
		  "    }",
		  "    ",
		  "    if (pid == 0)",
		  "    { ",
		  "        /* CODICE DEL FIGLIO*/",
		  "        for (j=0; j < N+1; j++)",
		  "        { ",
		  "            if (j != i+1){",
		  "                close(piped[j][1]);",
		  "            }",
		  "            if ((j != i) ){",
		  "                close (piped[j][0]);",
		  "            }",
		  "        }",
		  "",
		  "        /* INIZIO SINCRONIZZAZIONE*/",
		  "        dim = read(piped[i][0], &segnale, sizeof(segnale));",
		  "        if(dim != sizeof(segnale)){",
		  "            printf(\"Errore nella read del figlio %d\\n\", getpid());",
		  "            exit(-1);",
		  "        }",
		  "        ",
		  "        /*CODICE SINCRONIZZATO*/",
		  "",
		  "",
		  "        /*FINE CODICE SINCRONIZZATO*/",
		  "        dim = write(piped[i+1][1], &segnale, sizeof(segnale));",
		  "        if(dim != sizeof(segnale)){",
		  "            printf(\"Errore nella write del figlio %d\\n\", getpid());",
		  "            exit(-1);",
		  "        }",
		  "        }",
		  "",
		  "        exit(ritorno);",
		  "",
		  "        /*FINE CODICE DEL FIGLIO*/",
		  "    }",
		  "    printf(\"DEBUG: Generato figlio con PID = %d\\n\", pid);",
		  "}",
		  "",
		  "/* padre */",
		  "/* padre chiude tutte le pipe che non usa */",
		  "for (i=0; i < N+1; i++)",
		  "{",
		  "    if(i != N){",
		  "        close(piped[i][0]);",
		  "    }",
		  "    if(i != 0){",
		  "        close(piped[i][1]);",
		  "    }",
		  "    ",
		  "}",
		  "for(i = 0; i < ITERAZIONI; i++){",
		  "    //CODICE DA ESEGUIRE PRIMA DI TUTTI I FIGLI",
		  "    dim = write(piped[0][1], &segnale, sizeof(segnale));",
		  "    if(dim != sizeof(segnale)){",
		  "        printf(\"Errore nella write del padre\\n\");",
		  "        exit();",
		  "    }",
		  "    dim = read(piped[N][0], &segnale, sizeof(segnale));",
		  "    if(dim != sizeof(segnale)){",
		  "        printf(\"Errore nella read del padre\\n\");",
		  "        exit();",
		  "    }",
		  "}",
		  "for(int i=0; i<N;i++){",
		  "    if ((pidFiglio=wait(&status)) < 0)",
		  "    {",
		  "        //La wait non ha avuto successo",
		  "        printf(\"Errore in wait\\n\");",
		  "        exit();",
		  "    }",
		  "",
		  "    if (WIFEXITED(status)) {",
		  "        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
		  "        ritorno = WEXITSTATUS(status);",
		  "        printf(\"DEBUG: Il figlio %d e' ritornato con codice(se 255 problemi!): %d\\n\", pidFiglio,  ritorno);",
		  "    } else {",
		  "        //Lo status riporta una terminazione anomala",
		  "        printf(\"DEBUG: Il figlio %d e' terminato in modo anomalo\\n\", pidFiglio);",
		  "    }",
		  "}",
		  "",
		  ""
		],
		"description": "N figli sincronizzati a ring"
	  },
	  "Crea file o lo tronca se non esiste": {
		"prefix": "fileCrea",
		"body": [
		  "Fcreato_fd = open(${1:FILENAME}, O_CREAT | O_WRONLY | O_TRUNC, 0644);",
		  "if(Fcreato_fd < 0){",
		  "    printf(\"Errore nella creazione del file\\n\");",
		  "    exit(${2:EXITCODE});",
		  "}"
		],
		"description": "Crea file o lo tronca se non esiste"
	  },
	  "Determina la lunghezza in byte di un file": {
		"prefix": "lunghezzaFile",
		"body": [
		  "lunF = lseek(fd, 0, SEEK_END); /*Raggiungi la fine*/",
		  "lseek(fd, 0, SEEK_SET); /*All'inizio*/"
		],
		"description": "Determina la lunghezza in byte di un file"
	  },
	  "Figli N*2 con coppie tra figli e pipe tra coppie": {
		"prefix": "figliConCoppieEPipeTraCoppie",
		"body": [
		  "",
		  "",
		  "piped = malloc(sizeof(pipe_t) * N);",
		  "if(piped == NULL){",
		  "    printf(\"Errore nella malloc\\n\");",
		  "    exit(5);",
		  "}",
		  "",
		  "/* Creazione delle N pipe figli-padre */",
		  "for (j=0; j < N; j++)",
		  "{ ",
		  "    if(pipe(piped[j]) < 0)",
		  "    {  ",
		  "        printf(\"Errore nella creazione della pipe\\n\");",
		  "        exit(6);     ",
		  "    }",
		  "}",
		  "",
		  "",
		  "nrFigli = N*2;",
		  "// Per la creazione di N*2 figli",
		  "for(i=0; i < nrFigli; i++){",
		  "    if ((pidFiglio = fork()) < 0)",
		  "    {",
		  "        //Fork fallita",
		  "        printf(\"Errore in fork\\n\");",
		  "        exit(7);",
		  "    }",
		  "    ",
		  "    if (pidFiglio == 0)",
		  "    { ",
		  "        /* CODICE DEL FIGLIO*/",
		  "        primo = i < N;",
		  "        printf(\"DEBUG: Figlio, pid: %d, indice %d, nella coppia %d(1 primo, 0 secondo)\\n\", getpid(), i, primo);",
		  "        ",
		  "",
		  "        /* Chiusura delle pipe non usate nella comunicazione con il padre */",
		  "        for (j=0; j < N; j++)",
		  "        { ",
		  "            if (primo){",
		  "                close(piped[j][0]);",
		  "                if(j != i){",
		  "                    close(piped[j][1]);",
		  "                }",
		  "            }else{",
		  "                close(piped[j][1]);",
		  "                if(j != i-N){",
		  "                    close(piped[j][0]);",
		  "                }",
		  "            }",
		  "        }",
		  "",
		  "",
		  "        /*Se siamo il secondo figlio creo il file*/",
		  "        if(!primo){",
		  "            /*Creo spazio per ospitare nome del file + .mescolato*/",
		  "",
		  "            fcreato = malloc(strlen(argv[i-N+1]) + 10 + 1);",
		  "            strcat(fcreato, argv[i-N+1]);",
		  "            strcat(fcreato, \".mescolato\");",
		  "            nomeFile = argv[i-N+1];",
		  "            // Apro il file in scrittura, se non esiste lo creo, se esiste puo' dare errori",
		  "            if ( (fcreatoFD = open (fcreato, O_CREAT | O_WRONLY, 0644)) < 0 )",
		  "            { ",
		  "                printf(\"Errore in creazione file %s\\n\", fcreato);",
		  "                exit(-1);",
		  "            }",
		  "        }else{",
		  "            nomeFile = argv[i+1];",
		  "        }",
		  "",
		  "        if((fd = open(nomeFile, O_RDONLY)) < 0){",
		  "            printf(\"Errore: impossibile aprire il file %s\\n\", nomeFile);",
		  "            exit(-1);",
		  "        }",
		  "        lunF = lseek(fd, 0, SEEK_END); /*Raggiungi la fine*/",
		  "        if(primo){",
		  "            lseek(fd, 0, SEEK_SET); /*All'inizio*/",
		  "        }else{",
		  "            lseek(fd, lunF / 2, SEEK_SET); /*Al centro*/",
		  "        }",
		  "        nro = 0;",
		  "        while((n = read(fd, b, C)) > 0 && nro < (lunF / (2 * C))){",
		  "            if(n != C){",
		  "                printf(\"Errore nella lettura a blocchi del file %s\", nomeFile);",
		  "                exit(-1);",
		  "            }",
		  "            if(primo){",
		  "                n = write(piped[i][1], b, C);",
		  "                if(n != C){",
		  "                    printf(\"Errore nella scrittura verso il secondo figlio\\n\");",
		  "                    exit(-1);",
		  "                }",
		  "            }else{",
		  "                n = write(fcreatoFD, b, C);",
		  "                if(n != C){",
		  "                    printf(\"Errore nella scrittura sul file\\n\");",
		  "                    exit(-1);",
		  "                }",
		  "                n = read(piped[i-N][0], b, C);",
		  "                if(n != C){",
		  "                    printf(\"Errore nella lettura dal primo figlio\\n\");",
		  "                    exit(-1);",
		  "                }",
		  "                n = write(fcreatoFD, b, C);",
		  "                if(n != C){",
		  "                    printf(\"Errore nella scrittura sul file\\n\");",
		  "                    exit(-1);",
		  "                }",
		  "            }",
		  "            ++nro;",
		  "        }",
		  "        exit(nro);",
		  "",
		  "        /*FINE CODICE DEL FIGLIO*/",
		  "    }",
		  "}",
		  "",
		  "",
		  "/* padre chiude tutte le pipe che non usa */",
		  "for (j=0; j < N; j++)",
		  "{",
		  "    close(piped[j][0]);",
		  "    close(piped[j][1]);",
		  "}",
		  "",
		  "",
		  "// Il padre aspetta i figli salvando lo status",
		  "for(i=0; i<nrFigli;i++){",
		  "    if ((pidFiglio=wait(&status)) < 0)",
		  "    {",
		  "        //La wait non ha avuto successo",
		  "        printf(\"Errore in wait\\n\");",
		  "        exit(8);",
		  "    }",
		  "",
		  "    ",
		  "    if (WIFEXITED(status)) {",
		  "        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
		  "        ritorno = WEXITSTATUS(status);",
		  "        printf(\"Il figlio %d e' ritornato con %d blocchi letti, se 255 problemi!\\n\", pidFiglio, ritorno);",
		  "    } else {",
		  "        //Lo status riporta una terminazione anomala",
		  "        printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
		  "    }",
		  "}"
		],
		"description": "Figli N*2 con coppie tra figli e pipe tra coppie"
	  },
	  "figlio figlio a ring con padre che fa partire primo figlio": {
		"prefix": "figliConPipeFFePadreStartPrimoFiglio",
		"body": [
		  "    N = argc - 1;",
		  "    piped = malloc(N * sizeof(pipe_t));    ",
		  "    tutteLinee = malloc(N * sizeof(lin));",
		  "    if(piped == NULL || tutteLinee == NULL){",
		  "        printf(\"Errore in una malloc\\n\");",
		  "        exit(3);",
		  "    }",
		  "    ",
		  "    /* Creazione delle N pipe figli-padre */",
		  "    for (j=0; j < N; j++)",
		  "    { ",
		  "        if(pipe(piped[j]) < 0)",
		  "        {  ",
		  "            printf(\"Errore nella creazione della pipe\\n\");",
		  "            exit(3);     ",
		  "        }",
		  "    }",
		  "    printf(\"DEBUG: La pid del padre e' :%d\\n\", getpid());",
		  "    printf(\"DEBUG: Il padre deve generare %d figli\\n\", N);",
		  "    ",
		  "    ",
		  "    ",
		  "    // Per la creazione di N figli",
		  "    for(int n=0; n < N; n++){",
		  "        if ((pidFiglio = fork()) < 0)",
		  "        {",
		  "            //Fork fallita",
		  "            printf(\"Errore in fork\\n\");",
		  "            exit(4);",
		  "        }",
		  "        ",
		  "        if (pidFiglio == 0)",
		  "        { ",
		  "            /* CODICE DEL FIGLIO*/",
		  "    ",
		  "            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
		  "            for (j=0; j < N; j++)",
		  "            { ",
		  "                if (j != n){",
		  "                    close(piped[j][0]);",
		  "                }",
		  "                if(j != (n+1)%N){",
		  "                    close(piped[j][1]);",
		  "                }",
		  "            }",
		  "        ",
		  "",
		  "            F=argv[n+1];",
		  "            if((fd = open(F, O_RDONLY)) < 0){",
		  "                printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		  "                exit(-1);",
		  "            }",
		  "            j=0;",
		  "            //Lettura file carattere per carattere",
		  "            while((read(fd, &(linea[j]), 1)) > 0){",
		  "                if(linea[j] == '\\n'){",
		  "                    dim = read(piped[n][0], tutteLinee, sizeof(lin)* N);",
		  "                    if(dim != sizeof(lin) * N){",
		  "                        printf(\"Errore di lettura da pipe del figlio %d su propria pipe(exp: %ld, real: %ld)\\n\", n, sizeof(lin) * N, dim);",
		  "                        exit(-1);",
		  "                    }",
		  "                    for(i=0;i<=j;i++){",
		  "                        tutteLinee[n][i] = linea[i];",
		  "                    }",
		  "                    dim = write(piped[(n+1)%N][1], tutteLinee, sizeof(lin)* N);",
		  "                    ",
		  "                    if(dim != sizeof(lin) * N){",
		  "                        printf(\"Errore di scrittura da pipe del figlio %d su pipe %d\\n\", n, n+1);",
		  "                        exit(-1);",
		  "                    }",
		  "",
		  "                    if(n+1==N){",
		  "                        //Se e' l'ultimo figlio scrivo sul file",
		  "                        for(j=0;j<N;j++){",
		  "                            for(i=0;i<250;i++){",
		  "                                write(fdw, &(tutteLinee[j][i]), 1);",
		  "                                if(tutteLinee[j][i] == '\\n'){",
		  "                                    break;",
		  "                                }",
		  "                            }",
		  "                        }",
		  "                    }",
		  "                    ritorno = j+1;",
		  "                    j=0;",
		  "                }else{",
		  "                    j++;",
		  "                }",
		  "            }",
		  "            exit(ritorno);",
		  "            /*FINE CODICE DEL FIGLIO*/",
		  "        }",
		  "    }",
		  "    ",
		  "    ",
		  "    /* padre chiude tutte le pipe che non usa */",
		  "    for (j=1; j < N; j++)",
		  "    {",
		  "        close(piped[j][0]);",
		  "        close(piped[j][1]);",
		  "    }",
		  "    dim = write(piped[0][1], tutteLinee, sizeof(lin)* N); ",
		  "                  ",
		  "    if(dim != sizeof(lin) * N){",
		  "        printf(\"Errore di scrittura da pipe del padre sul figlio 0\\n\");",
		  "        exit(-1);",
		  "    }",
		  "    close(piped[0][1]); ",
		  "",
		  "    ",
		  "    // Il padre aspetta i figli salvando lo status",
		  "    for(i=0; i<N;i++){",
		  "        if ((pidFiglio=wait(&status)) < 0)",
		  "        {",
		  "            //La wait non ha avuto successo",
		  "            printf(\"Errore in wait\\n\");",
		  "            exit(5);",
		  "        }",
		  "    ",
		  "        ",
		  "        if (WIFEXITED(status)) {",
		  "            //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
		  "            ritorno = WEXITSTATUS(status);",
		  "            printf(\"Il figlio %d e' ritornato con %d caratteri letti sull'ultima linea, se 255 problemi!\\n\", pidFiglio, ritorno);",
		  "        } else {",
		  "            //Lo status riporta una terminazione anomala",
		  "            printf(\"DEBUG: Il figlio e' terminato in modo anomalo\\n\");",
		  "        }",
		  "    }",
		  "    "
		],
		"description": "figlio figlio a ring con padre che fa partire primo figlio"
	  },
		"printf": {
			"prefix": "printf",
			"body": [
				"printf(\"$1\\n\");"
			],
			"description": "Print to console"
		},
		"for": {
			"prefix": "for",
			"body": [
				"for (int ${1:i} = 0; ${1:i} < $2; ${1:i}++) {",
				"    $3",
				"}"
			],
			"description": "For loop"
		},
		"if": {
			"prefix": "if",
			"body": [
				"if ($1) {",
				"    $2",
				"}"
			],
			"description": "If statement"
		},
		"else": {
			"prefix": "else",
			"body": [
				"else {",
				"    $1",
				"}"
			],
			"description": "Else statement"
		},
		"else if": {
			"prefix": "elif",
			"body": [
				"else if ($1) {",
				"    $2",
				"}"
			],
			"description": "Else if statement"
		},
		"while": {
			"prefix": "while",
			"body": [
				"while ($1) {",
				"    $2",
				"}"
			],
			"description": "While loop"
		},
		"switch": {
			"prefix": "switch",
			"body": [
				"switch ($1) {",
				"    case $2:",
				"        $3",
				"        break;",
				"    default:",
				"        $4",
				"        break;",
				"}"
			],
			"description": "Switch statement"
		},
		"Controllo che sia singolo carattere": {
			"prefix": "singolo",
			"body": [
				"/* controllo che il ${2:XXXX} parametro sia un singolo carattere */",
				"if (argv[$1][1] != '\\0') {",
				"\tprintf(\"Error: %s non singolo carattere\\n\", argv[$1]);",
				"\texit(${3:0000});",
				"}",
				"char ${4:C} = argv[$1][0];"
			],
			"description": "Controllo che sia singolo carattere"
		},
		"Leggi tutto un file carattere per carattere": {
			"prefix": "leggiFileCaratterePerCarattere",
			"body": [
				"/* leggi tutto il file */",
				"char c;",
				"while (read(${1:file}, &c, 1)) {",
				"    printf(\"%c\", c);",
				"}"
			],
			"description": "Leggi tutto un file carattere per carattere"
		},
		"Leggi e trasforma file": {
			"prefix": "leggiTrasformaFile",
			"body": [
				"/* Leggo il file carattere per carattere */",
				"while (read(fd, &ch, 1)) {",
				"    /* controlliamo se abbiamo trovato un carattere alfabetico minuscolo */",
				"    if (islower(ch)) {",
				"        /* trasformiamo il carattere in maiuscolo */",
				"        ch = toupper(ch);",
				"        /* ci posizioniamo all'inizio del carattere da sovrascrivere */",
				"        lseek(fd, -1L, SEEK_CUR);",
				"        /* sovrascriviamo il carattere */",
				"        write(fd, &ch, 1);",
				"        /* incrementiamo il contatore delle trasformazioni */",
				"        trasformazioni++;",
				"    }",
				"}"
			],
			"description": "Leggi e trasforma file"
		},
		"Apri file in lettura": {
			"prefix": "apriFileLettura",
			"body": [
				"/* Apertura file in lettura */",
				"if ((fd = open(argv[$1], O_RDONLY)) < 0) {",
				"    printf(\"Errore in apertura file '%s' in lettura\\n\", argv[$1]);",
				"    exit(${2:0000});",
				"}"
			],
			"description": "Apri file in lettura"
		},
		"Apri file in scrittura o crealo o troncalo": {
			"prefix": "apriFileScritturaOCreatOTrunc",
			"body": [
				"/* Apertura file in scrittura */",
				"if ((fdw = open(argv[$1], O_WRONLY | O_CREAT | O_TRUNC, 0644)) < 0) {",
				"    printf(\"Errore in apertura file '%s' in scrittura\\n\", argv[$1]);",
				"    exit(${2:0000});",
				"}"
			],
			"description": "Apri file in scrittura o crealo o troncalo"
		},
		"Apri file in scrittura": {
			"prefix": "apriFileScrittura",
			"body": [
				"/* Apertura file in scrittura */",
				"if ((fdw = open(argv[$1], O_WRONLY)) < 0) {",
				"    printf(\"Errore in apertura file '%s' in scrittura\\n\", argv[$1]);",
				"    exit(${2:0000});",
				"}"
			],
			"description": "Apri file in scrittura"
		},
		"Crea file": {
			"prefix": "creaFile",
			"body": [
				"/* Creazione file */",
				"if ((fd = creat(argv[$1], 0644)) < 0) {",
				"    printf(\"Errore in creazione file '%s'\\n\", argv[$1]);",
				"    exit(${2:0000});",
				"}"
			],
			"description": "Crea file"
		},
		"Leggi il numero di righe di un file": {
			"prefix": "leggiNumeroRighe",
			"body": [
				"/* Leggi il numero di righe di un file */",
				"int righe = 0;",
				"char c;",
				"while (read(fd, &c, 1)) {",
				"    if (c == '\\n')",
				"        righe++;",
				"}"
			],
			"description": "Leggi il numero di righe di un file"
		},
		"Controllo numero parametri": {
			"prefix": "numeroParametri",
			"body": [
				"/* controllo numero parametri */",
				"if (argc != $1) {",
				"    printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"\tprintf(\"Uso: %s $2\\n\", argv[0]);",
				"    exit(${3:0000});",
				"}"
			],
			"description": "Controllo numero parametri"
		},
		"variabili locali": {
			"prefix": "variabiliLocali",
			"body": [
				"/* -------- Variabili locali ---------- */",
				"int pid;                \t\t/* process identifier per le fork() */",
				"int N;                  \t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"pipe_t *piped;          \t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"pipe_t p;               \t\t/* una sola pipe per ogni coppia figlio-nipote */",
				"int i, j;               \t\t/* indici per i cicli */",
				"int pidFiglio, status, ritorno;\t/* per valore di ritorno figli */",
				"$1",
				"/* ------------------------------------ */"
			],
			"description": "Variabili locali"
		},
		"Controllo che sia un numero strettamente positivo": {
			"prefix": "numeroPositivo",
			"body": [
				"/* controllo che il ${2:XXXX} parametro sia un numero strettamente positivo */",
				"int num = atoi(argv[$1]);",
				"if (num <= 0) {",
				"    printf(\"Error: %s non e' un numero strettamente positivo\\n\", argv[$1]);",
				"    exit(${3:0000});",
				"}"
			],
			"description": "Controllo che sia un numero strettamente positivo"
		},
		"creazione di N pipe": {
			"prefix": "creaPipe",
			"body": [
				"/* Creazione di N pipe */",
				"if ((piped = (pipe_t *) malloc(N * sizeof(pipe_t))) == NULL) {",
				"    printf(\"Errore allocazione pipe\\n\");",
				"    exit(${1:0000});",
				"}",
				"for (i = 0; i < N; i++) {",
				"    if (pipe(piped[i]) < 0) {",
				"        printf(\"Errore creazione pipe\\n\");",
				"        exit(${2:0000});",
				"    }",
				"}"
			],
			"description": "creazione di N pipe"
		},
		"Commento variabile del testo": {
			"prefix": "variabileTesto",
			"body": [
				"/* ATTENZIONE '$1' variabile del testo */"
			],
			"description": "Commento variabile del testo"
		},
		"Wait padre": {
			"prefix": "waitPadre",
			"body": [
				"/* Il padre aspetta i figli salvando lo status */",
				"for (int i = 0; i < N; i++) {",
				"    if ((pidFiglio = wait(&status)) < 0) {",
				"        printf(\"Errore in wait\\n\");",
				"        exit(5);",
				"    }",
				"    if ((status & 0xFF) != 0)",
				"        printf(\"Figlio con pid %d terminato in modo anomalo\\n\", pidFiglio);",
				"    else {",
				"        ritorno = (int)((status >> 8) & 0xFF);",
				"        printf(\"Il figlio con pid=%d ha ritornato il carattere %c (in decimale %d, se 255 problemi)\\n\", pidFiglio, ritorno, ritorno);",
				"    }",
				"}"
			],
			"description": "Wait padre"
		},
		"debug": {
			"prefix": "debug",
			"body": [
				"printf(\"--------------------------\\n\");",
				"printf(\"DEBUG: $1\\n\");",
				"printf(\"--------------------------\\n\");"
			],
			"description": "Debug"
		},
		"Pipeline figlio che comunica con il padre": {
			"prefix": "figlio->padre",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                \t\t\t/* process identifier per le fork() */",
				"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    int i, j;               \t\t\t/* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              \t\t\t\t/* file descriptor */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(piped[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si Ã¨ bloccato alla pipe di indice: %d!\\n\", i);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                close(piped[j][0]);",
				"                if(i != j)",
				"                    close(piped[j][1]);",
				"            }",
				"",
				"            /*###############son operation###################*/",
				"",
				"            exit(0); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Chiudo tutte le pipe di non interesse */",
				"    for(i = 0; i < N; i++) {",
				"        close(piped[i][1]);",
				"    }",
				"    ",
				"    /*###############father operation###################*/",
				"",
				"",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Pipeline figlio che comunica al padre"
		},
		"Pipeline nipote che comunica con il figlio e il figlio con il padre": {
			"prefix": "nipote->figlio->padre",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                \t\t\t/* process identifier per le fork() */",
				"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    pipe_t p;               \t\t\t/* una sola pipe per ogni coppia figlio-nipote */",
				"    int i, j;               \t\t\t/* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              \t\t\t\t/* file descriptor */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(piped[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si Ã¨ bloccato alla pipe di indice: %d!\\n\", i);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                close(piped[j][0]);",
				"                if(i != j)",
				"                    close(piped[j][1]);",
				"            }",
				"",
				"            /* creo la pipe per la comunicazione con il nipote */",
				"            if(pipe(p) < 0) {",
				"                printf(\"Errore: Impossibile creare la pipe di collegamento nipote-figlio con pid=%d del figlio %d-esimo!\\n\", getpid(), i);",
				"                exit(-1);",
				"            }",
				"",
				"            /* Genero il processo nipote e verifico che non ci siano errori */",
				"            if((pid = fork()) < 0) {",
				"                printf(\"Errore: Impossibile generare il processo nipote associato al processo figlio %d-esimo con pid=%d!\\n\", i, getpid());",
				"                exit(-1);",
				"            }",
				"",
				"            /* Codice del processo nipote */",
				"            if(pid == 0) {",
				"                /* Chiudo le pipe di non interesse del processo nipote */",
				"                close(piped[i][1]);",
				"                close(p[0]);",
				"",
				"                /*#########################nephew operation#########################*/",
				"",
				"                exit(0); /* return del nipote al figlio */",
				"            }",
				"",
				"            /* Chiudo la pipe di non interesse */",
				"            close(p[1]);",
				"",
				"            /*###############son operation###################*/",
				"",
				"",
				"            /* Aspetto la terminazione del processo nipote */",
				"            if ((pidWaitedSon = wait(&status)) < 0) {",
				"                printf(\"Errore in wait per il nipote associato al figlio %d-esimo con pid=%d!\\n\", i, getpid());",
				"                exit(-1);",
				"            }",
				"            if ((status & 0xFF) != 0)",
				"                printf(\"Il nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
				"            else {",
				"                ritorno = (int)((status >> 8) & 0xFF);",
				"                printf(\"--------------------------\\n\");",
				"                printf(\"DEBUG: Il nipote con pid=%d ha ritornato %d (se 255 problemi)\\n\", pidWaitedSon, ritorno);",
				"                printf(\"--------------------------\\n\");",
				"            }",
				"",
				"            exit(0); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Chiudo tutte le pipe di non interesse */",
				"    for(i = 0; i < N; i++) {",
				"        close(piped[i][1]);",
				"    }",
				"    ",
				"    /*###############father operation###################*/",
				"",
				"",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Pipeline nipote che comunica con il figlio e il figlio con il padre"
		},
		"Pipeline nipote E figlio comunica con il padre": {
			"prefix": "nipote+figlio->padre",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                \t\t\t/* process identifier per le fork() */",
				"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *pipedFP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    pipe_t *pipedNP;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni nipoti-padre  */",
				"    int i, j;               \t\t\t/* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              \t\t\t\t/* file descriptor */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione nipote-padre */",
				"    if(!(pipedNP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione nipote-padre!\\n\");",
				"        exit(3);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(pipedFP[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"        if(pipe(pipedNP[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il nipote %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(6);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                close(pipedFP[j][0]);",
				"                if(i != j)",
				"                    close(pipedFP[j][1]);",
				"            }",
				"",
				"            /* Creo il processo nipote */",
				"            if((pid = fork()) < 0) {",
				"                printf(\"Errore: Impossibile creare il processo nipote!\\n\");",
				"                exit(-1);",
				"            }",
				"",
				"            /* Codice del processo nipote */",
				"            if(pid == 0) {",
				"                /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
				"                close(pipedFP[i][1]);",
				"",
				"                /* Chiudo tutte le pipe di non interesse */",
				"                for(j = 0; j < N; j++) {",
				"                    close(pipedNP[j][0]);",
				"                    if(i != j)",
				"                        close(pipedNP[j][1]);",
				"                }",
				"",
				"                /*###############grandson operation###################*/",
				"",
				"                exit(0); /* return del nipote al figlio */",
				"            }",
				"",
				"            /* le pipe usate dal nipote vanno chiuse TUTTE */",
				"            for(j = 0; j < N; j++) {",
				"                close(pipedNP[j][0]);",
				"                close(pipedNP[j][1]);",
				"            }",
				"",
				"            /*###############son operation###################*/",
				"",
				"            /* il figlio aspetta il nipote */",
				"            if ((pidWaitedSon = wait(&status)) < 0) {",
				"                printf(\"Errore in wait per il nipote %d-esimo con pid=%d!\\n\", i, getpid());",
				"            }",
				"            if ((status & 0xFF) != 0)",
				"                printf(\"Nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
				"            else {",
				"                ritorno = (int)((status >> 8) & 0xFF);",
				"                printf(\"--------------------------\\n\");",
				"                printf(\"DEBUG: Il Nipote %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"                printf(\"--------------------------\\n\");",
				"            }",
				"",
				"            exit(0); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Chiudo tutte le pipe di non interesse */",
				"    for(i = 0; i < N; i++) {",
				"        close(pipedFP[i][1]);",
				"        close(pipedNP[i][1]);",
				"    }",
				"    ",
				"    /*###############father operation###################*/",
				"",
				"",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(7);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Pipeline nipote E figlio comunica con il padre"
		},
		"Figli che comunicano tra figli, ultimo figlio con il padre": {
			"prefix": "figlio->figlioN->padre",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid[100000];                \t/* process identifier per le fork() */",
				"    int N;                  \t\t\t/* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          \t\t\t/* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    int i, j;               \t\t\t/* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;\t/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int nr,nw;\t\t\t\t\t\t\t/* variabili per salvare valori di ritorno di read e write da/su pipe */",
				"    int fd;              \t\t\t\t/* file descriptor */",
				"    /* other variables */",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(piped[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si Ã¨ bloccato alla pipe di indice: %d!\\n\", i);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid[i] = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid[i] == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                if (j != i)",
				"                    close(piped[j][1]);",
				"                if ((i == 0) || (j != i-1))",
				"                    close(piped[j][0]);",
				"            }",
				"",
				"            /*###############son operation###################*/",
				"            if (i != 0) {",
				"",
				"                /* leggiamo dalla pipe il valore corrente */",
				"                nr = read(piped[i-1][0], /* data */NULL, sizeof(int));",
				"",
				"                if (nr != sizeof(int)) {",
				"                    printf(\"Errore in lettura dalla pipe %d-esima\\n\", i-1);",
				"                    exit(-1);",
				"                }",
				"            }",
				"",
				"            /* scriviamo sulla pipe il valore aggiornato */",
				"            nw = write(piped[i][1], /* data */NULL, sizeof(int));",
				"            if (nw != sizeof(int)) {",
				"                printf(\"Errore in scrittura sulla pipe %d-esima\\n\", i);",
				"                exit(-1);",
				"            }",
				"",
				"            exit(0); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Chiudo tutte le pipe di non interesse */",
				"    for(i = 0; i < N; i++) {",
				"        close(piped[i][1]);",
				"        if (i != N-1)",
				"            close(piped[i][0]);",
				"    }",
				"    ",
				"    /*###############father operation###################*/",
				"    /* il padre deve leggere un solo array, chiaramente controllando l'esito della lettura! */",
				"    nr = read(piped[N-1][0], /* data */NULL, sizeof(int));",
				"    if (nr != sizeof(int)) {",
				"        printf(\"Errore in lettura dalla pipe %d-esima\\n\", N-1);",
				"        exit(4);",
				"    } else {",
				"        /* some operation */",
				"        for(i = 0; i < N; i++) {",
				"            /* some operation */",
				"        }",
				"    }",
				"",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Figli con comunicazione tra figli, ultimo figlio con il padre"
		},
		"mia_random": {
			"prefix": "random",
			"body": [
				"#include <time.h>",
				"//DA AGGIUNGERE NEL MAIN",
				"//srand(time(NULL));",
				"//PER OTTENERE RANDOM",
				"//int r = mia_random(100);",
				"",
				"int mia_random(int n) {",
				"\tint casuale;",
				"\tcasuale = rand() % n;",
				"\treturn casuale;",
				"}"
			],
			"description": "Generate a random number between 0 and n-1"
		},
		"convertiUltimaStringaInNumero": {
			"prefix": "convertiUltimaStringaInNumero",
			"body": [
				"H = atoi(argv[argc-1]);",
				"if ((H <= 0) || (H >= 255)) {",
				"\tprintf(\"Errore nel numero passato %d\\n\", H);",
				"\texit(000000);",
				"}"
			],
			"description": "Convert the last string argument to a number and perform error checking"
		},
		"creazione file in /tmp": {
			"prefix": "creaFileTmp",
			"body": [
				"/* creazione file in /tmp */",
				"/* usato la open in versione estesa per azzerare il file nel caso esista gia' */",
				"if ((fdout=open(\"/tmp/creato\", O_CREAT|O_WRONLY|O_TRUNC, 0644)) < 0) {",
				"\tprintf(\"Errore nella creazione del file %s\\n\", \"/tmp/creato\");",
				"\texit(00000);",
				"}"
			],
			"description": "Creazione file in /tmp"
		},
		"Pipeline figlio comunica con il padre e il padre risponde al figlio": {
			"prefix": "figlio->padre->figlio",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                /* process identifier per le fork() */",
				"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *pipedFP;/* array dinamico di pipe descriptors per comunicazioni figli-padre */",
				"    pipe_t *pipedPF;/* array dinamico di pipe descriptors per comunicazioni padre-figli */",
				"    int i, j;               /* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              /* file descriptor */",
				"    char linea[255];/* array di caratteri per memorizzare la linea, supponendo una lunghezza massima di ogni linea di 255 caratteri compreso il terminatore di linea */",
				"    int valore; /* variabile che viene usata dal padre per recuperare il valore comunicato da ogni figlio e che contiene la lunghezza della linea corrente */",
				"    int giusto; /* variabile che viene usata dal padre per salvare per ogni linea il valore inviato dal figlio selezionato in modo random */",
				"    int r; /* variabile usata dal padre per calcolare i valori random e dal figlio per ricevere il numero dal padre */",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione padre-figlio */",
				"    if(!(pipedPF = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione padre-figlio!\\n\");",
				"        exit(3);",
				"    }",
				"",
				"    /* Creazione delle N pipe figli-padre e delle N pipe padre-figli */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(pipedFP[i]) < 0) {",
				"            printf(\"Errore: Impossibile creare la pipe figlio-padre %d-esima!\\n\", i);",
				"            exit(4);",
				"        }",
				"        if(pipe(pipedPF[i]) < 0) {",
				"            printf(\"Errore: Impossibile creare la pipe padre-figlio %d-esima!\\n\", i);",
				"            exit(5);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(6);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
				"            for (j = 0; j < N; j++) {",
				"                close(pipedFP[j][0]);",
				"                close(pipedPF[j][1]);",
				"                if (i != j) {",
				"                    close(pipedFP[j][1]);",
				"                    close(pipedPF[j][0]);",
				"                }",
				"            }",
				"",
				"            /*###############son operation###################*/",
				"",
				"            /* Apro il file in sola lettura */",
				"            if((fd = open(argv[i + 1], O_RDONLY)) < 0) {",
				"                printf(\"Errore: Impossibile aprire il file %s in sola lettura!\\n\", argv[i + 1]);",
				"                exit(-1);",
				"            }",
				"",
				"            /* adesso il figlio legge dal file una linea alla volta */",
				"            j=0;",
				"            while(read(fd, &(linea[j]), 1)){",
				"                if(linea[j] == '\\n'){",
				"                    /* dobbiamo mandare al padre la lunghezza della linea corrente compreso il terminatore di linea (come int) e quindi incrementiamo j */",
				"                    j++;write(pipedFP[i][1], &j, sizeof(j));",
				"                    /* il figlio Pi deve leggere il valore inviato dal padre */",
				"                    read(pipedPF[i][0], &r, sizeof(r));",
				"",
				"                    if (r < j) {",
				"                        /* other operation */",
				"                        // .............",
				"                    } else {",
				"                        j = 0; /* azzeriamo l'indice per le prossime linee */",
				"                    }",
				"                } else {",
				"                    j++;",
				"                }",
				"            }",
				"",
				"            exit(0); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Il padre chiude i lati delle pipe che non usa */",
				"    for (i = 0; i < N; i++) {",
				"        close(pipedFP[i][1]);",
				"        close(pipedPF[i][0]);",
				"    }",
				"",
				"    /*###############father operation###################*/",
				"",
				"        /* example ---------------------------------------> */",
				"    /* Il padre recupera le informazioni dai figli: prima in ordine di linee e quindi in ordine di indice */",
				"    for (j = 1; j <= NUM; j++) {",
				"        for (i = 0; i < N; i++) {",
				"            /* il padre recupera tutti i valori interi dai figli */",
				"            read(pipedFP[i][0], &valore, sizeof(valore));",
				"            /* ma si salva solo il valore del figlio identificato in modo random */",
				"            if (i == r)",
				"                giusto = valore;",
				"        }",
				"        r = mia_random(giusto);",
				"        /* il padre deve inviare a tutti i figli l'indice */",
				"        for (i = 0; i < N; i++)",
				"            write(pipedPF[i][1], &r, sizeof(r));",
				"    }",
				"    ",
				"",
				"",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Pipeline figlio comunica con il padre e il padre risponde al figlio"
		},
		"Pipeline Ring figlio padre": {
			"prefix": "ringFiglioPadre",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                /* process identifier per le fork() */",
				"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    int i, j;               /* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              /* file descriptor */",
				"    int nr,nw;              /* variabili per salvare valori di ritorno di read/write da/su pipe */",
				"    char ok;/* carattere letto dai figli dalla pipe precedente e scritta su quella successiva */",
				"    char ch;       /* carattere lette dai figli dall'unico file */",
				"    int nrChar;/* contatore carattere cercato per ogni linea */",
				"    int L;/* per valore numero linee del file */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc((N + 1) * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N + 1; i++) {",
				"        if(pipe(piped[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si Ã¨ bloccato alla pipe di indice: %d!\\n\", i);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N + 1; j++) {",
				"                if(i != j)",
				"                    close(piped[j][0]);",
				"                if(j != (i + 1))",
				"                    close(piped[j][1]);",
				"            }",
				"",
				"            /*###############son operation###################*/",
				"                /* EXAMPLES OF SON OPERATION --------------------*/",
				"",
				"            /* apertura file */",
				"            if ((fd = open(argv[1], O_RDONLY)) < 0) {",
				"                printf(\"Impossibile aprire il file %s\\n\", argv[1]);",
				"                exit(-1);",
				"            }",
				"",
				"            /* inizializziamo il contatore del carattere cercato per ogni singola linea */",
				"            nrChar = 0;",
				"            /* con un ciclo leggiamo tutte le linee, come richiede la specifica */",
				"            while (read(fd, &ch, 1) != 0) {",
				"                if (ch == '\\n') { /* siamo a fine linea */",
				"                    /* dobbiamo aspettare l'ok dal figlio precedente per scrivere */",
				"                    nr = read(piped[q][0], &ok, sizeof(char));",
				"                    /* per sicurezza controlliamo il risultato della lettura da pipe */",
				"                    if (nr != sizeof(char)) {",
				"                        printf(\"Figlio %d ha letto un numero di byte sbagliati %d\\n\", q, nr);",
				"                        exit(-1);",
				"                    }",
				"                    /* a questo punto si deve riportare su standard output l'indice e il pid del processo, il numero di caratteri cercato presenti e la linea letta */",
				"                    printf(\"Figlio con indice %d e pid %d ha letto %d caratteri %c nella linea corrente\\n\", q, getpid(), nrChar, argv[q + 3][0]);",
				"                    /* ora si deve mandare l'OK in avanti: nota che il valore della variabile ok non ha importanza */",
				"                    nw = write(piped[q + 1][1], &ok, sizeof(char));",
				"                    /* anche in questo caso controlliamo il risultato della scrittura */",
				"                    if (nw != sizeof(char)) {",
				"                        printf(\"Figlio %d ha scritto un numero di byte sbagliati %d\\n\", q, nw);",
				"                        exit(-1);",
				"                    }",
				"                    /* si deve azzerare il conteggio delle occorrenze, dopo averlo salvato per poterlo tornare correttamente, nel caso la linea corrente sia l'ultima! */",
				"                    ritorno = nrChar;",
				"                    nrChar = 0;",
				"                } else {",
				"                    /* se non siamo a fine linea dobbiamo fare il controllo sul carattere corrente */",
				"                    if (ch == argv[q + 3][0]) { /* se abbiamo letto il carattere da cercare incrementiamo il contatore */",
				"                        nrChar++;",
				"                    }",
				"                }",
				"            }",
				"            /* ogni figlio deve tornare il numero di caratteri numerici dell'ultima linea */",
				"            exit(ritorno); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* chiusura di tutte le pipe che non usa, a parte la prima e l'ultima */",
				"    for (i = 0; i < N + 1; i++) {",
				"        if (i != N) close(piped[i][0]);",
				"        if (i != 0) close(piped[i][1]);",
				"    }",
				"",
				"    /* Poiche' in questo caso il padre e' nel ring, non ci sono problemi di dover lasciare aperti lati di pipe che il padre non usa! */",
				"",
				"    ",
				"    /*###############father operation###################*/",
				"",
				"        /* EXAMPLES OF FATHER OPERATION --------------------*/",
				"    for (j = 0; j < L; j++) { /* il padre deve leggere una riga per volta da ciascun file */",
				"        /* il padre deve riportare il numero di linea correntemente analizzata dai figli, insieme con il nome del file */",
				"        printf(\"Linea %d del file %s\\n\", j + 1, argv[1]); /* il numero di linea deve partire da 1! */",
				"        /* il padre deve inviare un 'segnale' di sincronizzazione al processo di indice 0 */",
				"        nw = write(piped[0][1], &ok, sizeof(char));",
				"        /* anche in questo caso controlliamo il risultato della scrittura */",
				"        if (nw != sizeof(char)) {",
				"            printf(\"Padre ha scritto un numero di byte sbagliati %d\\n\", nw);",
				"            exit(7);",
				"        }",
				"        /* il padre quindi deve aspettare che l'ultimo figlio gli invii il 'segnale' di sincronizzazione per fare ripartire il ring */",
				"        nr = read(piped[Q][0], &ok, sizeof(char));",
				"        /* per sicurezza controlliamo il risultato della lettura da pipe */",
				"        if (nr != sizeof(char)) {",
				"            printf(\"Padre ha letto un numero di byte sbagliati %d\\n\", nr);",
				"            exit(8);",
				"        }",
				"    }",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Pipeline Ring figlio padre"
		},
		"funzione finitof": {
			"prefix": "finitof",
			"body": [
				"/* VARIABILI GLOBALI */",
				"int *finito;  /* array dinamico per indicare i figli che sono terminati */",
				"/* la semantica di questo array e' che ogni elemento vale 0 se il corrispondente processo NON e' finito, altrimenti vale 1 */",
				"int N;        /* numero di processi figli: deve essere una variabile globale perche' deve essere usata dalla funzione finitof */",
				"/* ATTENZIONE 'N' nome indicato nel testo */",
				"int finitof() {",
				"    /* questa funzione verifica i valori memorizzati nell'array finito: ",
				"    appena trova un elemento uguale a 0 vuole dire che non tutti i processi ",
				"    figli sono finiti e quindi torna 0; tornera' 1 se e solo se tutti gli elementi ",
				"    dell'array sono a 1 e quindi tutti i processi sono finiti */",
				"",
				"    for (int i = 0; i < N; i++) {",
				"        if (!finito[i]) {",
				"            /* appena ne trova uno che non ha finito */",
				"            return 0; /* ritorna falso */",
				"        }",
				"    }",
				"    return 1;",
				"}",
				"",
				"// initialize finito nel main",
				"/* allocazione memoria dinamica per finito */",
				"finito = (int *) malloc(sizeof(int) * N);",
				"if(finito == NULL) {",
				"    printf(\"Errore nella allocazione della memoria per array finito\\n\");",
				"    exit(2);",
				"}",
				"/* ... e inizializzazione a 0: all'inizio nessun figlio e' finito */",
				"memset(finito, 0, sizeof(int) * N);"
			],
			"description": "Funzione finitof"
		},
		"Pipeline while !finito": {
			"prefix": "signalConFinitoPipe",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <string.h> /* STRING: memset */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"/* VARIABILI GLOBALI */",
				"int *finito;  /* array dinamico per indicare i figli che sono terminati */",
				"/* la semantica di questo array e' che ogni elemento vale 0 se il corrispondente processo NON e' finito, altrimenti vale 1 */",
				"int N;        /* numero di processi figli: deve essere una variabile globale perche' deve essere usata dalla funzione finitof */",
				"/* nome indicato nel testo */",
				"",
				"int finitof() {",
				"    /* questa funzione verifica i valori memorizzati nell'array finito: ",
				"    appena trova un elemento uguale a 0 vuole dire che non tutti i processi ",
				"    figli sono finiti e quindi torna 0; tornera' 1 se e solo se tutti gli elementi ",
				"    dell'array sono a 1 e quindi tutti i processi sono finiti */",
				"",
				"    for (int i = 0; i < N; i++) {",
				"        if (!finito[i]) {",
				"            /* appena ne trova uno che non ha finito */",
				"            return 0; /* ritorna falso */",
				"        }",
				"    }",
				"    return 1;",
				"}",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc < 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s file1 file2 ...\\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                /* process identifier per le fork() */",
				"    pipe_t *pipedFP;        /* array dinamico di pipe descriptors per comunicazioni figli-padre */",
				"    pipe_t *pipedPF;        /* array dinamico di pipe descriptors per comunicazioni padre-figli */",
				"    int n, j;               /* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;                 /* file descriptor */",
				"    char linea[255];        /* array di caratteri per memorizzare la linea, supponendo una lunghezza massima di ogni linea di 255 caratteri compreso il terminatore di linea */",
				"    char car;               /* variabile usata dal padre per leggere gli ultimi caratteri delle linee inviati dai figli */",
				"    char chMax;             /* variabile usata dal padre per tenere traccia del carattere di codice ASCII massimo */",
				"    char chControllo;       /* variabile per inviare indicazione ai figli */",
				"    int indice;             /* variabile usata dal padre per tenere traccia dell'indice del figlio che ha calcolato il massimo */",
				"    int stampe;             /* numero di stampe fatte dai figli che va ritornato al padre */",
				"    int nr, nw;             /* per controlli read e write su/da pipe */",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* allocazione memoria dinamica per finito */",
				"    finito = (int *) malloc(sizeof(int) * N);",
				"    if(finito == NULL) {",
				"        printf(\"Errore nella allocazione della memoria per array finito\\n\");",
				"        exit(2);",
				"    }",
				"    /* ... e inizializzazione a 0: all'inizio nessun figlio e' finito */",
				"    memset(finito, 0, N * sizeof(int));",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(pipedFP = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione padre-figlio */",
				"    if(!(pipedPF = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione padre-figlio!\\n\");",
				"        exit(3);",
				"    }",
				"",
				"    /* Creazione delle N pipe figli-padre e delle N pipe padre-figli */",
				"    for(n = 0; n < N; n++) {",
				"        if(pipe(pipedFP[n]) < 0) {",
				"            printf(\"Errore: Impossibile creare la pipe figlio-padre %d-esima!\\n\", n);",
				"            exit(4);",
				"        }",
				"        if(pipe(pipedPF[n]) < 0) {",
				"            printf(\"Errore: Impossibile creare la pipe padre-figlio %d-esima!\\n\", n);",
				"            exit(5);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(n = 0; n < N; n++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", n);",
				"            exit(6);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiusura delle pipe non usate nella comunicazione con il padre */",
				"            for (j = 0; j < N; j++) {",
				"                close(pipedFP[j][0]);",
				"                close(pipedPF[j][1]);",
				"                if (n != j) {",
				"                    close(pipedFP[j][1]);",
				"                    close(pipedPF[j][0]);",
				"                }",
				"            }",
				"",
				"            /* Apro il file in sola lettura */",
				"            if((fd = open(argv[n + 1], O_RDONLY)) < 0) {",
				"                printf(\"Errore: Impossibile aprire il file %s in sola lettura!\\n\", argv[n + 1]);",
				"                exit(-1);",
				"            }",
				"",
				"            /* adesso il figlio legge dal file una linea alla volta */",
				"            j=0;",
				"            /* inizializziamo le stampe a 0 */",
				"            stampe = 0;",
				"",
				"            while(read(fd, &(linea[j]), 1)){",
				"                if(linea[j] == '\\n'){",
				"                    /* inviamo l'ultimo carattere (escluso il terminatore di linea) al padre, avendo ipotizzato che ogni file contenga SEMPRE per ogni linea almeno un carattere oltre il terminatore di linea*/",
				"",
				"                    nw = write(pipedFP[n][1], &linea[j - 1], 1);",
				"                    if(nw != 1){",
				"                        printf(\"Errore: impossibile scrivere il carattere %c sulla pipe figlio-padre %d-esima\\n\", linea[j - 1], n);",
				"                        exit(-1);",
				"                    }",
				"",
				"                    /* aspettiamo dal risposta da padre se stampare o meno */",
				"                    nr = read(pipedPF[n][0], &chControllo, 1);",
				"                    if(nr != 1){",
				"                        printf(\"Errore: impossibile leggere il carattere di controllo dalla pipe padre-figlio %d-esima\\n\", n);",
				"                        exit(-1);",
				"                    }",
				"",
				"                    if (chControllo == 'S') {",
				"                        ",
				"                        /* stampiamo la linea */",
				"                        linea[j + 1] = '\\0'; /* mettiamo il terminatore di stringa */",
				"                        printf(\"Sono il figlio di indice %d e pid %d e ho trovato una linea con un ultimo carattere '%c' con codice ASCII maggiore degli altri nel file %s. Ecco la linea:\\n%s\", n, getpid(), linea[j-1], argv[n+1], linea);",
				"                        stampe++; /* incrementiamo il contatore delle stampe */",
				"                    }",
				"",
				"                    j = 0; /* azzeriamo l'indice per le prossime linee */",
				"                } else {",
				"                    j++; /* incrementiamo l'indice per la prossima lettura */",
				"                }",
				"            }",
				"",
				"            exit(stampe); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Il padre chiude n lati delle pipe che non usa */",
				"    for (n = 0; n < N; n++) {",
				"        close(pipedFP[n][1]);",
				"        close(pipedPF[n][0]);",
				"    }",
				"",
				"    /* continuiamo a ciclare su tutti i figli in ordine, finche' tutti non hanno finito */",
				"    while(!finitof()) {",
				"\t\tchMax = -1; /* ATTENZIONE: il valore del massimo, va resettato per ogni insieme di valori letti dal padre */",
				"\t\tfor (n = 0; n < N; n++) {",
				"\t\t    /* tentiamo di leggere il carattere dal figlio i-esimo: contestualmente viene aggiornato il valore del corrispondente elemento dell'array finito */",
				"\t\t    finito[n] = (read(pipedFP[n][0], &car, 1) != 1);  /* nel caso la read torni un valore diverso da 1, il corrispondente valore di finito viene settato a 1 dato che la condizione e' vera! */",
				"\t\t",
				"\t\t    if (!finito[n]) {",
				"\t\t        if (car > chMax) {",
				"\t\t            /* dobbiamo aggiornare il massimo */",
				"\t\t            chMax = car;",
				"\t\t            /* debbiamo tenere conto dell'indice del processo che ha inviato il massimo */",
				"\t\t            indice = n;",
				"\t\t        }",
				"\t\t    }",
				"\t\t}",
				"\t\t/* bisogna mandare ai figli l'indicazione giusta (S per scrivere, N per NON scrivere) */",
				"\t\tfor (n = 0; n < N; n++) {",
				"\t\t    if (n == indice) /* figlio che deve scrivere */",
				"\t\t        chControllo = 'S';",
				"\t\t    else chControllo = 'N';",
				"\t\t    if (!finito[n]) {",
				"\t\t        nw = write(pipedPF[n][1], &chControllo, 1); ",
				"\t\t        if (nw != 1) {",
				"\t\t            printf(\"PADRE non e' riuscito ad inviare nulla al figlio di indice %d \\n\", n);",
				"\t\t        }",
				"\t\t    }",
				"\t\t}",
				"        printf(\"DEBUG-PADRE valore della funzione finitof=%d\\n\", finitof());",
				"    }",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (n = 0; n < N; n++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", n);",
				"            exit(5);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", n, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", n, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "pipeline figlio padre, padre figlio con while !finito"
		},
		"Ring tra i figli": {
			"prefix": "ringTraFigli",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"typedef char L[250]; /* Definizione di un tipo L come array di 250 caratteri */",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc < 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s file1 file2 ... fileN \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                /* process identifier per le fork() */",
				"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    int n, i, j, k;               /* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;              /* file descriptor */",
				"    int nr,nw;              /* variabili per salvare valori di ritorno di read/write da/su pipe */",
				"    int fdout;  /* file descriptor per la creazione del file */",
				"    L linea;    /* per salvare la linea letta */",
				"    L* tutteLinee; /* per salvare tutte le linee lette */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(n = 0; n < N; n++) {",
				"        if(pipe(piped[n]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe, si Ã¨ bloccato alla pipe di indice: %d!\\n\", n);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    /* allocazione dell'array delle linee */",
				"    if ((tutteLinee = (L *) malloc(N * sizeof(L))) == NULL) {",
				"        printf(\"Errore nell'allocazione dell'array delle linee\\n\");",
				"        exit(4);",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* creazione file in cervinschi */",
				"    /* usato la open in versione estesa per azzerare il file nel caso esista gia' */",
				"    if ((fdout=creat(\"Cervinschi\", 0644)) < 0) {",
				"        printf(\"Errore nella creazione del file %s\\n\", \"cervinschi\");",
				"        exit(5);",
				"    }",
				"",
				"    /* Creo N processi figli */",
				"    for(n = 0; n < N; n++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", n);",
				"            exit(6);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Sono il figlio con pid=%d e indice %d, associato al file %s\\n\", getpid(), n, argv[n + 1]);",
				"            printf(\"--------------------------\\n\");",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                if (j != n) {",
				"                    close(piped[j][0]);",
				"                }",
				"                if (j != (n + 1) % N) {",
				"                    close(piped[j][1]);",
				"                }",
				"            }",
				"",
				"            /* apertura file */",
				"            if ((fd = open(argv[n + 1], O_RDONLY)) < 0) {",
				"                printf(\"Impossibile aprire il file %s\\n\", argv[n + 1]);",
				"                exit(-1);",
				"            }",
				"",
				"            /* inizializziamo il contatore del carattere cercato per ogni singola linea */",
				"            j = 0;",
				"            /* con un ciclo leggiamo tutte le linee, come richiede la specifica */",
				"            while (read(fd, &(linea[j]), 1) != 0) {",
				"                if (linea[j] == '\\n') { /* siamo a fine linea */",
				"",
				"                    nr = read(piped[n][0], tutteLinee, N*sizeof(L));",
				"                    /* per sicurezza controlliamo il risultato della lettura da pipe */",
				"                    if (nr != N*sizeof(L)) {",
				"                        printf(\"Figlio %d ha letto un numero di byte sbagliati %d\\n\", n, nr);",
				"                        exit(-1);",
				"                    }",
				"",
				"                    /* insetiamo la linea letta al posto giusto */",
				"                    for (k = 0; k <= j; k++) {",
				"                        tutteLinee[n][k] = linea[k];",
				"                    }",
				"",
				"                    nw = write(piped[(n + 1)%N][1], tutteLinee, N*sizeof(L));",
				"                    /* anche in questo caso controlliamo il risultato della scrittura */",
				"                    if (nw != N*sizeof(L)) {",
				"                        printf(\"Figlio %d ha scritto un numero di byte sbagliati %d\\n\", n, nw);",
				"                        exit(-1);",
				"                    }",
				"",
				"                    if (n == N - 1) {",
				"                        /* se siamo all'ultimo figlio, scriviamo la linea su file */",
				"                        for (i = 0; i < N; i++) {",
				"                            for (k = 0; k < 250; k++) {",
				"                                write(fdout, &(tutteLinee[i][k]), 1);",
				"                                if (tutteLinee[i][k] == '\\n') {",
				"                                    break;",
				"                                }",
				"                            }",
				"                        }",
				"                    } ",
				"                    ritorno = j+1;",
				"                    j = 0;",
				"                } else {",
				"                    j++;",
				"                }",
				"            }",
				"            /* ogni figlio deve tornare il numero di caratteri numerici dell'ultima linea */",
				"            exit(ritorno); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* chiusura di tutte le pipe che non usa, a parte la prima e l'ultima */",
				"    for (n = 1; n < N; n++) {",
				"        close(piped[n][0]);",
				"        close(piped[n][1]);",
				"    }",
				"    /* Poiche' in questo caso il padre e' nel ring, non ci sono problemi di dover lasciare aperti lati di pipe che il padre non usa! */",
				"",
				"    /* mandiamo al primo figlio l'array delle linee */",
				"    nw = write(piped[0][1], tutteLinee, N*sizeof(L));",
				"    if (nw != N*sizeof(L)) {",
				"        printf(\"Padre ha scritto un numero di byte sbagliati %d\\n\", nw);",
				"        exit(7);",
				"    }",
				"",
				"    /* chiudiamo il lato di scrittura della pipe */",
				"    close(piped[0][1]);",
				"",
				"    ",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (n = 0; n < N; n++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", n);",
				"            exit(8);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", n, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", n, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Creazione di un ring tra i figli"
		},
		"Pipeline Padre comunica con il figlio che comunica con il nipote che esegue comandi shell": {
			"prefix": "padre->figlio->nipote->SH",
			"body": [
				"/* File ${TM_FILENAME} */",
				"/* Standard C = C11 */",
				"",
				"#include <stdio.h> /* Standard I/O: printf, BUFSIZ */",
				"#include <fcntl.h> /* File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR */",
				"#include <stdlib.h> /* STanDard LIBrary: exit, malloc, calloc, free, atoi */",
				"#include <unistd.h> /* UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END */",
				"#include <sys/wait.h> /* SYStem WAIT: wait */",
				"#include <string.h> /* per la funzione strlen */",
				"#include <sys/stat.h> /* per la funzione open */",
				"",
				"typedef int pipe_t[2]; /* Definizione di un tipo pipe_t come array di 2 interi */",
				"",
				"int main(int argc, char const **argv) {",
				"    /* controllo numero parametri */",
				"    if (argc != 3) {",
				"        printf(\"Error: numero parametri '%d' errato\\n\", argc - 1);",
				"        printf(\"Uso: %s \\n\", argv[0]);",
				"        exit(1);",
				"    }",
				"",
				"    /* -------- Variabili locali ---------- */",
				"    int pid;                /* process identifier per le fork() */",
				"    int N;                  /* numero di file passati sulla riga di comando (uguale al numero di file) */",
				"    pipe_t *piped;          /* array dinamico di pipe descriptors per comunicazioni figli-padre  */",
				"    pipe_t p;/* una sola pipe per ogni coppia figlio-nipote */",
				"    int i, j;              /* indici per i cicli */",
				"    int pidWaitedSon, status, ritorno;/* per valore di ritorno dei vari processi (figli/nipoti) */",
				"    int fd;             /* file descriptor */",
				"    ",
				"    /* ------------------------------------ */",
				"",
				"",
				"    /* Salvo il numero dei file in una variabile */",
				"    N = argc - 1; ",
				"",
				"    /* Alloco memoria per l'array delle pipe per la comunicazione figlio-padre */",
				"    if(!(piped = (pipe_t*) malloc(N * sizeof(pipe_t)))) {",
				"        printf(\"Errore: Impossibile allocare memoria per l'array delle pipe per la comunicazione figlio-padre!\\n\");",
				"        exit(2);",
				"    }",
				"",
				"    /* Inizializzo l'array delle pipe */",
				"    for(i = 0; i < N; i++) {",
				"        if(pipe(piped[i]) < 0) {",
				"            printf(\"Errore: Impossibile inizializzare l'array delle pipe per il figlio %d-esimo!\\n\", i);",
				"            exit(3);",
				"        }",
				"    }",
				"",
				"    printf(\"--------------------------\\n\");",
				"    printf(\"DEBUG: Sono il padre con pid=%d e sto per creare [%d] figli!\\n\", getpid(), N);",
				"    printf(\"--------------------------\\n\");",
				"",
				"    /* Creo N processi figli */",
				"    for(i = 0; i < N; i++) {",
				"",
				"        if((pid = fork()) < 0) {",
				"            printf(\"Errore: Impossibile creare il processo figlio %d-esimo!\\n\", i);",
				"            exit(4);",
				"        }",
				"",
				"        /* Codice del processo figlio */",
				"        if(pid == 0) {",
				"",
				"            /* Chiudo tutte le pipe di non interesse */",
				"            for(j = 0; j < N; j++) {",
				"                close(piped[j][0]);",
				"                if(i != j) {",
				"                    close(piped[j][1]);",
				"                }",
				"            }",
				"",
				"            /* Creo la pipe per la comunicazione fra figlio e nipote */",
				"            if(pipe(p) < 0) {",
				"                printf(\"Errore: Impossibile creare la pipe per la comunicazione fra figlio %d-esimo e nipote!\\n\");",
				"                exit(-1);",
				"            }",
				"",
				"            /* Creo il processo nipote */",
				"            if((pid = fork()) < 0) {",
				"                printf(\"Errore: Impossibile creare il processo nipote!\\n\");",
				"                exit(-1);",
				"            }",
				"",
				"            /* Codice del processo nipote */",
				"            if(pid == 0) {",
				"                /* chiusura della pipe rimasta aperta di comunicazione fra figlio-padre che il nipote non usa */",
				"                close(piped[i][1]);",
				"",
				"                ",
				"                /* Ridirezione dello standard input: DA FARE SOLO SE RICHIEDE UN COMANDO-FILTRO*/",
				"                close(0);",
				"                if (open(argv[i + 1], O_RDONLY) < 0) {",
				"                    printf(\"Errore nella open del file %s\\n\", argv[i+1]);",
				"                    exit(-1); /* si veda commento precedente */",
				"                }",
				"                ",
				"                /* ogni nipote deve simulare il piping dei comandi nei confronti del figlio/padre e quindi deve chiudere lo standard output e quindi usare la dup sul lato di scrittura della propria pipe */",
				"                close(1);",
				"                dup(p[1]);             ",
				"",
				"                /* ogni nipote adesso puo' chiudere entrambi i lati della pipe: il lato 0 non viene usato e il lato 1 viene usato tramite lo standard output */",
				"                close(p[0]);",
				"                close(p[1]);",
				"",
				"                /* Ridirezione dello standard error su /dev/null (per evitare messaggi di errore a video) */",
				"                close(2);",
				"                open(\"/dev/null\", O_WRONLY);",
				"                ",
				"                /* Il nipote diventa il comando wc -l */        ",
				"                execlp( ...... , (char *)0);",
				"                ",
				"                /* Non si dovrebbe mai tornare qui!!*/",
				"                exit(-1); /* si veda commento precedente */",
				"            }",
				"",
				"            /* codice figlio */",
				"            /* ogni figlio deve chiudere il lato che non usa della pipe di comunicazione con il nipote */",
				"            close(p[1]);",
				"            ",
				"            /* adesso il figlio legge dalla pipe un carattere alla volta */",
				"            j=0;",
				"          ",
				"            while (read(p[0], &SOST, 1)) {",
				"                /* implementare richieste*/",
				"                j++;",
				"            }",
				"",
				"            /* il figlio comunica al padre */",
				"            write(piped[i][1], &SOST, sizeof(SOST));",
				"",
				"            /* il figlio deve aspettare il nipote per restituire il valore al padre */",
				"            /* se il nipote e' terminato in modo anomalo decidiamo di tornare -1 e verra' interpretato come 255 e quindi segnalando questo problema al padre */",
				"",
				"            ritorno = -1; /* valore di ritorno del nipote */",
				"            /* il figlio aspetta il nipote */",
				"            if ((pidWaitedSon = wait(&status)) < 0) {",
				"                printf(\"Errore in wait per il nipote %d-esimo con pid=%d!\\n\", i, getpid());",
				"            }",
				"            if ((status & 0xFF) != 0)",
				"                printf(\"Nipote con pid %d terminato in modo anomalo\\n\", pidWaitedSon);",
				"            else {",
				"                ritorno = (int)((status >> 8) & 0xFF);",
				"                printf(\"--------------------------\\n\");",
				"                printf(\"DEBUG: Il Nipote %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"                printf(\"--------------------------\\n\");",
				"            }",
				"",
				"            exit(ritorno); /* return del figlio al padre */",
				"        }",
				"    }",
				"",
				"    /* Codice del processo padre */",
				"",
				"    /* Il padre chiude i lati delle pipe che non usa */",
				"    for (i=0; i < N; i++) {",
				"        close(piped[i][1]);",
				"    }",
				"",
				"    /* Il padre recupera le informazioni dai figli in ordine di indice */",
				"    for (i = 0; i < N; i++) {",
				"        read(piped[i][0], &SOST, sizeof(SOST));",
				"        printf(\"\", ...);",
				"    }",
				"",
				"    /* Il padre aspetta i figli salvando lo status */",
				"    for (int i = 0; i < N; i++) {",
				"        if ((pidWaitedSon = wait(&status)) < 0) {",
				"            printf(\"Errore in wait per il figlio %d-esimo!\\n\", i);",
				"            exit(7);",
				"        }",
				"        if ((status & 0xFF) != 0)",
				"            printf(\"Figlio %d-esimo con pid %d terminato in modo anomalo\\n\", i, pidWaitedSon);",
				"        else {",
				"            ritorno = (int)((status >> 8) & 0xFF);",
				"            printf(\"--------------------------\\n\");",
				"            printf(\"DEBUG: Il figlio %d-esimo con pid=%d ha ritornato %d (se 255 problemi)\\n\", i, pidWaitedSon, ritorno);",
				"            printf(\"--------------------------\\n\");",
				"        }",
				"    }",
				"",
				"    exit(0); /* return del padre al sistema */",
				"}"
			],
			"description": "Nipote comunica con il figlio che comunica con il padre + comando SH"
		},
		"EXECL example": {
			"prefix": "execl",
			"body": [
				"execl(\"/bin/ls\", \"ls\", \"-l\", (char *)0);"
			],
			"description": "execl example"
		},
		"EXECLP example": {
			"prefix": "execlp",
			"body": [
				"execlp(\"ls\", \"ls\", \"-l\", (char *)0);"
			],
			"description": "execlp example"
		},
		"EXECV example": {
			"prefix": "execv",
			"body": [
				"char *args[] = {\"ls\", \"-l\", (char *)0};",
				"execv(\"/bin/ls\", args);"
			],
			"description": "execv example"
		},
		"EXECVP example": {
			"prefix": "execvp",
			"body": [
				"char *args[] = {\"ls\", \"-l\", (char *)0};",
				"execvp(\"ls\", args);"
			],
			"description": "execvp example"
		},
		"EXECVE example": {
			"prefix": "execve",
			"body": [
				"char *args[] = {\"ls\", \"-l\", (char *)0};",
				"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
				"execve(\"/bin/ls\", args, env);"
			],
			"description": "execve example"
		},
		"EXECLE example": {
			"prefix": "execle",
			"body": [
				"char *args[] = {\"ls\", \"-l\", (char *)0};",
				"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
				"execle(\"/bin/ls\", \"ls\", \"-l\", (char *)0, env);"
			],
			"description": "execle example"
		},
		"EXECVPE example": {
			"prefix": "execvpe",
			"body": [
				"char *args[] = {\"ls\", \"-l\", (char *)0};",
				"char *env[] = {\"HOME=/\", \"LOGNAME=home\", (char *)0};",
				"execvpe(\"ls\", args, env);"
			],
			"description": "execvpe example"
		},
		"Ridirezione dello stdin su /dev/null":{
			"prefix": "stdin->/dev/null",
			"body": [
				"/* Ridirezione dello stdin su /dev/null */",
				"close(0);",
				"open(\"/dev/null\", O_RDONLY);"
			],
			"description": "Ridirezione dello stdin su /dev/null"
		},
		"Ridirezione dello stdout su /dev/null":{
			"prefix": "stdout->/dev/null",
			"body": [
				"/* Ridirezione dello stdout su /dev/null */",
				"close(1);",
				"open(\"/dev/null\", O_WRONLY);"
			],
			"description": "Ridirezione dello stdout su /dev/null"
		},
		"Ridirezione dello stderr su /dev/null":{
			"prefix": "stderr->/dev/null",
			"body": [
				"/* Ridirezione dello stderr su /dev/null */",
				"close(2);",
				"open(\"/dev/null\", O_WRONLY);"
			],
			"description": "Ridirezione dello stderr su /dev/null"
		}
}